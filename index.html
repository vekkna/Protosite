<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8">
        <title>Wargame Prototype v6 (Synced)</title>
        <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
        <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
        <style>
            body {
                font-family: sans-serif;
                background-color: #222;
                color: #ccc;
                margin: 0;
                padding: 20px;
                display: flex;
                justify-content: center;
                height: 100vh;
                overflow: hidden;
                user-select: none;
            }

            #container {
                display: flex;
                gap: 20px;
            }

            /* --- SIDEBARS --- */
            .sidebar {
                width: 180px;
                background-color: #444;
                padding: 10px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                border: 2px solid #555;
                text-align: center;
            }

            .palette-item {
                padding: 15px;
                font-weight: bold;
                color: white;
                cursor: grab;
                border: 2px solid rgba(255, 255, 255, 0.2);
                margin-bottom: 5px;
            }

            .palette-item:hover {
                border-color: white;
            }

            /* --- BUTTONS --- */
            button {
                padding: 10px;
                cursor: pointer;
                border: none;
                color: white;
                font-weight: bold;
            }

            .btn-red {
                background-color: #d32f2f;
                border: 2px solid white;
            }

            .btn-red:active {
                background-color: #b71c1c;
            }

            .btn-grey {
                background-color: #666;
                color: #fff;
            }

            .btn-grey:active {
                background-color: #444;
            }

            .btn-blue {
                background-color: #1976d2;
                border: 1px solid #63a4ff;
            }

            .btn-blue:active {
                background-color: #0d47a1;
            }

            input[type="text"] {
                width: 90%;
                padding: 5px;
                margin-bottom: 5px;
                background: #222;
                border: 1px solid #555;
                color: white;
                text-align: center;
            }

            /* --- CONNECTION STATUS --- */
            #status-indicator {
                padding: 5px;
                font-size: 0.8em;
                margin-bottom: 10px;
                border-radius: 4px;
                background-color: #333;
                color: #888;
            }

            .status-connected {
                background-color: #2e7d32 !important;
                color: white !important;
            }

            /* --- TABLE --- */
            #game-table {
                position: relative;
                background-color: #35654d;
                /* Felt Green */
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
                overflow: hidden;
                cursor: crosshair;
            }

            /* --- PIECES --- */
            .piece {
                position: absolute;
                display: flex;
                align-items: center;
                justify-content: center;
                text-align: center;
                box-sizing: border-box;
                cursor: grab;
                transition: transform 0.1s ease-out;
            }

            .piece:active {
                cursor: grabbing;
            }

            .unit {
                font-weight: bold;
                font-size: 12px;
                color: white;
                border: 2px solid rgba(255, 255, 255, 0.8);
                z-index: 10;
                background-color: #555;
                padding: 2px;
                line-height: 1.1;
            }

            .wound-marker {
                position: absolute;
                top: -10px;
                right: -10px;
                background-color: #d32f2f;
                color: white;
                border: 2px solid white;
                border-radius: 50%;
                width: 24px;
                height: 24px;
                font-size: 14px;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 15;
                display: none;
            }

            .terrain {
                color: white;
                font-weight: bold;
                text-shadow: 1px 1px 2px black;
                z-index: 5;
                opacity: 0.9;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .terrain.forest {
                background-color: #1b5e20;
                border: 2px dashed #4caf50;
                border-radius: 50%;
            }

            .terrain.hills {
                background-color: #795548;
                border: 2px solid #3e2723;
                border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
            }

            .terrain.rough {
                background-color: #9e9d24;
                border: 2px dotted #f0f4c3;
                border-radius: 20% 80% 40% 60% / 60% 40% 70% 30%;
            }

            /* --- VISUAL FX --- */
            .ghost {
                opacity: 0.3;
                pointer-events: none;
                z-index: 1;
            }

            .range-ring {
                position: absolute;
                border: 2px solid rgba(255, 0, 0, 0.6);
                background-color: rgba(255, 0, 0, 0.1);
                border-radius: 50%;
                pointer-events: none;
                z-index: 2;
                transform: translate(-50%, -50%);
            }

            /* --- UI LAYER --- */
            #ui-layer {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 20;
            }

            #measure-line {
                stroke: yellow;
                stroke-width: 3;
                stroke-dasharray: 10, 5;
                opacity: 0;
            }

            #measure-text {
                font-size: 18px;
                font-weight: bold;
                fill: yellow;
                text-shadow: 1px 1px 2px black;
                opacity: 0;
            }

            #controls-hint {
                margin-top: auto;
                font-size: 0.8em;
                color: #888;
                text-align: left;
            }
        </style>
    </head>

    <body>
        <div id="container">
            <div class="sidebar">
                <h3 style="margin-top:0">Multiplayer</h3>
                <div id="status-indicator">OFFLINE</div>
                <button id="host-btn" class="btn-blue" onclick="hostGame()">Host Game</button>
                <input type="text" id="my-id-display" placeholder="Your ID will appear here" readonly
                    style="display:none;">
                <button id="copy-btn" class="btn-grey" onclick="copyId()" style="display:none; margin-bottom:10px;">Copy
                    ID</button>
                <div style="border-top: 1px solid #666; margin: 5px 0;"></div>
                <input type="text" id="join-input" placeholder="Enter Host ID">
                <button id="join-btn" class="btn-blue" onclick="joinGame()">Join Game</button>
                <h3 style="margin-top:20px">Tools</h3>
                <button id="dice-btn" class="btn-red" onclick="rollDice()">Roll 2d6</button>
                <div id="dice-result">-</div>
                <div id="dice-detail"></div>
                <button onclick="undo()" class="btn-grey" style="margin-top: 15px;">Undo (Z)</button>
                <button onclick="resetGame()" class="btn-grey" style="margin-top: 5px;">Reset Board</button>
            </div>
            <div id="game-table">
                <svg id="ui-layer">
                    <line id="measure-line" x1="0" y1="0" x2="0" y2="0" />
                    <text id="measure-text" x="0" y="0">0"</text>
                </svg>
            </div>
            <div class="sidebar">
                <h3 style="margin-top:0">Terrain</h3>
                <div class="palette-item" style="background-color: #1b5e20;" onmousedown="spawnTerrain('forest')">Forest
                </div>
                <div class="palette-item" style="background-color: #795548;" onmousedown="spawnTerrain('hills')">Hills
                </div>
                <div class="palette-item" style="background-color: #9e9d24;" onmousedown="spawnTerrain('rough')">Rough
                </div>
                <div id="stats-panel" style="
    width: 100%; 
    background: #222; 
    border: 1px solid #555; 
    margin-top: 10px; 
    padding: 10px;
    box-sizing: border-box; /* Prevents padding from causing overflow */
    display: flex; 
    flex-direction: column; /* Vertical stacking */
    gap: 8px;
    color: #ccc; 
    font-family: monospace; 
    font-size: 13px;
    text-align: left;">
                    <span style="color: #666; text-align: center;">Hover unit for stats</span>
                </div>
                <div id="controls-hint">
                    <p><strong>Controls:</strong></p>
                    <p>Drag: Move (Ghost)</p>
                    <p>Click Empty: Measure</p>
                    <p>Wheel: Rotate</p>
                    <p>Double Click: Rename Unit</p>
                    <p>Hover+R: Range (12")</p>
                    <p>Hover Unit: +/- Wounds</p>
                    <p>Hover Terrain: +/- Size</p>
                    <p>Z / Ctrl+Z: Undo</p>
                </div>
            </div>
        </div>
        <script>
            // --- CONFIGURATION ---
            const SCALE = 20;
            const TABLE_WIDTH_FT = 4;
            const TABLE_DEPTH_FT = 3;
            const UNIT_WIDTH_MM = 88;
            const UNIT_DEPTH_MM = 63;
            const DEPLOY_INCHES = 6;
            const TERRAIN_DEFAULT_W = 6;
            const TERRAIN_DEFAULT_H = 4;
            const THREAT_RANGE_INCHES = 12;
            // New Version Key to wipe old bad data
            const SAVE_KEY = 'wargameSave_v6';

            // --- CONVERSIONS ---
            const mmToInches = (mm) => mm / 25.4;
            const inchesToPx = (inch) => inch * SCALE;
            const pxToInches = (px) => (px / SCALE).toFixed(1);

            const tableWidthPx = inchesToPx(TABLE_WIDTH_FT * 12);
            const tableHeightPx = inchesToPx(TABLE_DEPTH_FT * 12);
            const unitWidthPx = inchesToPx(mmToInches(UNIT_WIDTH_MM));
            const unitHeightPx = inchesToPx(mmToInches(UNIT_DEPTH_MM));

            // --- SETUP TABLE ---
            const table = document.getElementById('game-table');
            table.style.width = `${tableWidthPx}px`;
            table.style.height = `${tableHeightPx}px`;

            // --- PEERJS / NETWORK STATE ---
            let peer = null;
            let conn = null;
            let isHost = false;

            // --- GAME STATE ---
            let activePiece = null;
            let ghostPiece = null;
            let isMeasuring = false;
            let anchorX = 0;
            let anchorY = 0;
            let hoveredUnit = null;
            let hoveredTerrain = null;
            let undoStack = [];
            const MAX_UNDO = 20;

            const lineElement = document.getElementById('measure-line');

            // Add your NEW CSV link here
            const RULES_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?gid=2000929092&single=true&output=csv';

            let globalRulesDB = []; // Stores the keyword rules

            function loadRules() {
                Papa.parse(RULES_URL, {
                    download: true,
                    header: false, // Assuming no headers, just like your main sheet
                    skipEmptyLines: true,
                    complete: function (results) {
                        // Store as an array of objects: [{keyword: "Elf", effect: "..."}]
                        globalRulesDB = results.data.map(row => ({
                            keyword: row[0].trim(), // Column A
                            effect: row[1].trim()   // Column B
                        }));
                        console.log("Rules loaded:", globalRulesDB.length);
                    }
                });
            }

            // Call this at the bottom of your script, near loadStats()
            loadRules();

            // --- STATS INTEGRATION ---
            const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?output=csv';

            let unitStatsDB = {};

            function loadStats() {
                Papa.parse(SHEET_URL, {
                    download: true,
                    header: true,
                    skipEmptyLines: true,
                    // 1. This strips whitespace from headers (e.g. "Unit " becomes "Unit")
                    transformHeader: function (header) {
                        return header.trim();
                    },
                    complete: function (results) {
                        // 2. Debugging: Check the first row to see valid keys
                        if (results.data.length > 0) {
                            console.log("CSV Headers Detected:", Object.keys(results.data[0]));
                        }

                        results.data.forEach(row => {
                            // 3. Robust check: Ensure row.Unit exists before trying to trim it
                            if (row.Unit) {
                                unitStatsDB[row.Unit.trim()] = row;
                            } else {
                                // Optional: Log rows that failed to parse (helps find typos)
                                console.warn("Skipped row (Missing 'Unit' column):", row);
                            }
                        });
                        console.log("Stats loaded:", Object.keys(unitStatsDB).length, "units found.");
                        console.log("Available Units:", Object.keys(unitStatsDB));
                    },
                    error: function (err) {
                        console.error("Error loading stats:", err);
                    }
                });
            }
            function updateStatsPanel(unitName) {
                const panel = document.getElementById('stats-panel');
                if (!unitName) {
                    panel.innerHTML = '<span style="color: #666; text-align: center;">Hover unit for stats</span>';
                    return;
                }

                const cleanName = unitName.trim();
                const stats = unitStatsDB[cleanName];

                // 1. Find all matching rules based on the name
                let activeRules = [];

                // Check our new Global Rules DB
                globalRulesDB.forEach(rule => {
                    if (cleanName.includes(rule.keyword)) {
                        activeRules.push(rule.effect);
                    }
                });

                // Also include any specific "Special" text from the main stats sheet (Column G) if you have it
                if (stats && stats.Special) {
                    activeRules.push(stats.Special);
                }

                if (stats) {
                    // Create HTML for rules
                    const rulesHtml = activeRules.length > 0
                        ? `<div style="margin-top:8px; padding-top:8px; border-top:1px solid #444;">
                 ${activeRules.map(r => `<div style="margin-bottom:4px; font-size:0.9em; color:#ddd;">â€¢ ${r}</div>`).join('')}
               </div>`
                        : "";

                    panel.innerHTML = `
            <div style="font-weight:bold; color:white; border-bottom:1px solid #444; padding-bottom:4px; margin-bottom:4px;">
                ${stats.Unit}
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                <span>M: <b style="color:#fff">${stats.Move}</b></span>
                <span>R: <b style="color:#fff">${stats.Range}"</b></span>
                <span>S: <b style="color:#fff">${stats.Shoot}</b></span>
                <span>Str: <b style="color:#fff">${stats.Strike}</b></span>
                <span>Def: <b style="color:#fff">${stats.Defence}</b></span>
            </div>
            ${rulesHtml}
        `;
                } else {
                    panel.innerHTML = `<span style="color: #d32f2f;">Stats not found</span>`;
                }
            }

            // Initialize
            loadStats();

            // --- NETWORKING FUNCTIONS ---

            // Helper to make the short ID
            function generateShortId() {
                const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
                let result = '';
                for (let i = 0; i < 4; i++) { // Change 4 to 5 if you want more security
                    result += chars.charAt(Math.floor(Math.random() * chars.length));
                }
                return result;
            }

            function hostGame() {
                if (peer) return;
                updateStatus("Initializing...");

                // Generate the custom short ID
                const shortId = generateShortId();

                // Pass the ID into the Peer constructor
                peer = new Peer(shortId);

                peer.on('open', (id) => {
                    updateStatus("Hosting");
                    document.getElementById('my-id-display').style.display = 'block';
                    document.getElementById('my-id-display').value = id; // Will show the 4-char ID
                    document.getElementById('copy-btn').style.display = 'block';
                    document.getElementById('host-btn').style.display = 'none';
                    document.getElementById('join-input').style.display = 'none';
                    document.getElementById('join-btn').style.display = 'none';
                    isHost = true;
                });

                // Rest of the error handling remains the same...
                peer.on('connection', (c) => {
                    conn = c;
                    setupConnection();
                    setTimeout(() => sendData({ type: 'SYNC_BOARD', payload: getBoardState() }), 500);
                });
                peer.on('error', (err) => {
                    console.error(err);
                    // Retry logic if by random chance the ID is taken (very rare)
                    if (err.type === 'unavailable-id') {
                        peer = null;
                        hostGame();
                    }
                });
            }

            function joinGame() {
                const hostId = document.getElementById('join-input').value.trim();
                if (!hostId) return alert("Enter a Host ID");
                updateStatus("Connecting...");
                peer = new Peer();
                peer.on('open', () => {
                    conn = peer.connect(hostId);
                    setupConnection();
                });
                peer.on('error', (err) => {
                    updateStatus("Error");
                    alert("Could not connect. Check ID.");
                });
            }

            function setupConnection() {
                if (!conn) return;
                conn.on('open', () => {
                    updateStatus("Connected!");
                    document.getElementById('status-indicator').classList.add('status-connected');
                });
                conn.on('data', (data) => {
                    handleIncomingData(data);
                });
                conn.on('close', () => {
                    updateStatus("Disconnected");
                    document.getElementById('status-indicator').classList.remove('status-connected');
                    conn = null;
                });
            }

            function handleIncomingData(data) {
                if (data.type === 'SYNC_BOARD') {
                    restoreBoardState(data.payload, true);
                }
                else if (data.type === 'ROLL_DICE') {
                    document.getElementById('dice-result').innerText = data.result;
                    document.getElementById('dice-detail').innerText = data.detail + " (Opponent)";
                }
            }

            function sendData(dataObj) {
                if (conn && conn.open) {
                    conn.send(dataObj);
                }
            }

            function updateStatus(msg) {
                document.getElementById('status-indicator').innerText = msg;
            }

            function copyId() {
                const copyText = document.getElementById("my-id-display");
                copyText.select();
                navigator.clipboard.writeText(copyText.value);
                alert("ID Copied to Clipboard!");
            }

            // --- SERIALIZATION (THE FIX) ---
            // Now reads explicit data attributes rather than extracting from messy DOM text
            function getBoardState() {
                const pieces = [];

                // Serialize Units
                document.querySelectorAll('.unit').forEach(el => {
                    if (el.classList.contains('ghost')) return;
                    pieces.push({
                        type: 'unit',
                        name: el.dataset.name, // Read clean name from dataset
                        x: parseFloat(el.style.left),
                        y: parseFloat(el.style.top),
                        angle: el.dataset.angle,
                        wounds: el.dataset.wounds,
                        color: el.style.backgroundColor
                    });
                });

                // Serialize Terrain
                document.querySelectorAll('.terrain').forEach(el => {
                    pieces.push({
                        type: 'terrain',
                        subType: el.dataset.subType, // Read clean subtype from dataset
                        x: parseFloat(el.style.left),
                        y: parseFloat(el.style.top),
                        w: parseFloat(el.style.width),
                        h: parseFloat(el.style.height),
                        angle: el.dataset.angle
                    });
                });

                return JSON.stringify(pieces);
            }

            function restoreBoardState(jsonString, suppressBroadcast = false) {
                if (!jsonString) return;

                table.querySelectorAll('.unit, .terrain, .ghost, .range-ring').forEach(p => p.remove());

                const data = JSON.parse(jsonString);
                data.forEach(obj => {
                    if (obj.type === 'unit') {
                        createUnitDOM(obj.name, obj.color, obj.x, obj.y, obj.angle, obj.wounds);
                    } else if (obj.type === 'terrain') {
                        createTerrainDOM(obj.subType, obj.x, obj.y, obj.w, obj.h, obj.angle);
                    }
                });

                saveGame(suppressBroadcast);
            }

            function saveGame(suppressBroadcast = false) {
                const state = getBoardState();
                localStorage.setItem(SAVE_KEY, state);
                if (!suppressBroadcast) {
                    sendData({ type: 'SYNC_BOARD', payload: state });
                }
            }

            // --- DOM FACTORIES ---
            function createUnitDOM(name, color, x, y, angle, wounds) {
                const div = document.createElement('div');
                div.classList.add('piece', 'unit');
                div.style.backgroundColor = color;
                div.style.width = `${unitWidthPx}px`;
                div.style.height = `${unitHeightPx}px`;
                div.style.left = `${x}px`;
                div.style.top = `${y}px`;
                div.innerText = name;
                div.dataset.name = name;
                div.dataset.angle = angle || 0;
                div.style.transform = `rotate(${angle}deg)`;
                div.dataset.wounds = wounds || 0;

                // Helper to ensure marker exists after renaming
                const appendMarker = () => {
                    let marker = div.querySelector('.wound-marker');
                    if (!marker) {
                        marker = document.createElement('div');
                        marker.classList.add('wound-marker');
                        div.appendChild(marker);
                    }
                    const w = div.dataset.wounds;
                    marker.innerText = w;
                    marker.style.display = (parseInt(w) > 0) ? 'flex' : 'none';
                };

                div.addEventListener('mouseenter', () => {
                    hoveredUnit = div;
                    updateStatsPanel(div.dataset.name); // <--- Add this
                });

                div.addEventListener('mouseleave', () => {
                    hoveredUnit = null;
                    removeRangeRing();
                    updateStatsPanel(null); // <--- Add this
                });

                appendMarker(); // Add initial marker

                attachListeners(div);
                div.addEventListener('mouseenter', () => hoveredUnit = div);
                div.addEventListener('mouseleave', () => { hoveredUnit = null; removeRangeRing(); });

                // --- NEW: Double Click to Rename ---
                div.addEventListener('dblclick', (e) => {
                    e.stopPropagation(); // Prevent measuring tape trigger
                    const currentName = div.dataset.name;
                    const newName = prompt("Rename Unit:", currentName);

                    if (newName !== null && newName.trim() !== "") {
                        pushUndo();
                        div.innerText = newName; // This wipes children (the marker)
                        div.dataset.name = newName;
                        appendMarker(); // Put the marker back
                        saveGame();
                    }
                });

                table.appendChild(div);
                return div;
            }

            function createTerrainDOM(subType, x, y, w, h, angle) {
                // Fallback for missing data
                if (!subType || subType === "undefined") subType = "rough";
                const finalW = w || inchesToPx(TERRAIN_DEFAULT_W);
                const finalH = h || inchesToPx(TERRAIN_DEFAULT_H);

                const div = document.createElement('div');
                // Add specific class based on subType
                div.classList.add('piece', 'terrain', subType);
                div.innerText = subType.charAt(0).toUpperCase() + subType.slice(1);
                div.style.left = `${x}px`;
                div.style.top = `${y}px`;
                div.style.width = `${finalW}px`;
                div.style.height = `${finalH}px`;

                // STORE DATA EXPLICITLY
                div.dataset.subType = subType;
                div.dataset.angle = angle || 0;
                div.style.transform = `rotate(${angle}deg)`;

                attachListeners(div);
                div.addEventListener('mouseenter', () => hoveredTerrain = div);
                div.addEventListener('mouseleave', () => hoveredTerrain = null);

                table.appendChild(div);
                return div;
            }

            // --- GAME LOGIC ---
            function pushUndo() {
                if (undoStack.length >= MAX_UNDO) undoStack.shift();
                undoStack.push(getBoardState());
            }

            window.undo = function () {
                if (undoStack.length === 0) return;
                const previousState = undoStack.pop();
                restoreBoardState(previousState);
            };

            window.resetGame = function () {
                if (confirm("Reset board?")) {
                    localStorage.removeItem(SAVE_KEY);
                    location.reload();
                }
            };

            function rollDice() {
                const d1 = Math.floor(Math.random() * 6) + 1;
                const d2 = Math.floor(Math.random() * 6) + 1;
                const total = d1 + d2;
                const detail = `(${d1} + ${d2})`;
                document.getElementById('dice-result').innerText = total;
                document.getElementById('dice-detail').innerText = detail;
                sendData({ type: 'ROLL_DICE', result: total, detail: detail });
            }

            // --- INITIALIZATION ---
            function initGame() {
                const saved = localStorage.getItem(SAVE_KEY);
                if (saved) {
                    restoreBoardState(saved, true);
                } else {
                    createDefaultUnits();
                    createDefaultTerrain();
                    saveGame(true);
                }
            }

            function createDefaultUnits() {
                const sides = ['red', 'blue'];
                const unitNames = ["Elf Cavalry", "Human Mounted Archers", "Orc Archers", "Dwarf Swords", "Undead Spears", "Elf Skirmishers"];
                const deployYPositions = [inchesToPx(DEPLOY_INCHES), tableHeightPx - inchesToPx(DEPLOY_INCHES)];

                sides.forEach((color, sideIndex) => {
                    const yPos = deployYPositions[sideIndex];
                    const spacing = tableWidthPx / 7;
                    const initialAngle = (sideIndex === 0) ? 180 : 0;

                    unitNames.forEach((name, i) => {
                        const x = (spacing * (i + 1)) - (unitWidthPx / 2);
                        const y = yPos - (unitHeightPx / 2);
                        createUnitDOM(name, color, x, y, initialAngle, 0);
                    });
                });
            }

            function createDefaultTerrain() {
                const terrainTypes = ['forest', 'forest', 'hills', 'hills', 'rough', 'rough'];
                terrainTypes.forEach((type) => {
                    const w = inchesToPx(TERRAIN_DEFAULT_W);
                    const h = inchesToPx(TERRAIN_DEFAULT_H);
                    const x = Math.random() * (tableWidthPx - w - 100) + 50;
                    const y = Math.random() * (inchesToPx(26) - inchesToPx(10)) + inchesToPx(10);
                    const angle = Math.floor(Math.random() * 360);
                    createTerrainDOM(type, x, y, w, h, angle);
                });
            }

            window.spawnTerrain = function (type) {
                pushUndo();
                const w = inchesToPx(TERRAIN_DEFAULT_W);
                const h = inchesToPx(TERRAIN_DEFAULT_H);
                const div = createTerrainDOM(type, -9999, -9999, w, h, 0);

                activePiece = div;
                ghostPiece = null;
                anchorX = -1;
                div.dataset.offsetX = w / 2;
                div.dataset.offsetY = h / 2;

                saveGame();
            };

            function attachListeners(element) {
                element.addEventListener('mousedown', onPieceDragStart);
                element.addEventListener('wheel', onWheel);
            }

            // --- INPUT HANDLING ---
            window.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
                if (e.key === 'z') { undo(); return; }

                if (e.key.toLowerCase() === 'r' && hoveredUnit) showRangeRing(hoveredUnit);

                const isPlus = (e.key === '+' || e.key === '=' || e.code === 'NumpadAdd');
                const isMinus = (e.key === '-' || e.key === '_' || e.code === 'NumpadSubtract');

                if (!isPlus && !isMinus) return;

                pushUndo();

                if (hoveredUnit) {
                    let wounds = parseInt(hoveredUnit.dataset.wounds);
                    const marker = hoveredUnit.querySelector('.wound-marker');
                    if (isPlus) wounds++;
                    if (isMinus && wounds > 0) wounds--;
                    hoveredUnit.dataset.wounds = wounds;
                    marker.innerText = wounds;
                    marker.style.display = (wounds > 0) ? 'flex' : 'none';
                }
                else if (hoveredTerrain) {
                    let w = parseFloat(hoveredTerrain.style.width);
                    let h = parseFloat(hoveredTerrain.style.height);
                    const factor = isPlus ? 1.1 : 0.9;
                    hoveredTerrain.style.width = `${w * factor}px`;
                    hoveredTerrain.style.height = `${h * factor}px`;
                }
                saveGame();
            });

            window.addEventListener('keyup', (e) => {
                if (e.key.toLowerCase() === 'r') removeRangeRing();
            });

            function showRangeRing(unit) {
                // if (unit.querySelector('.range-ring')) return;
                // const ring = document.createElement('div');
                // ring.classList.add('range-ring');
                // const diameterPx = inchesToPx(THREAT_RANGE_INCHES * 2);
                // ring.style.width = `${diameterPx}px`;
                // ring.style.height = `${diameterPx}px`;
                // ring.style.left = '50%';
                // ring.style.top = '50%';
                // unit.appendChild(ring);
            }
            function removeRangeRing() {
                // document.querySelectorAll('.range-ring').forEach(r => r.remove());
            }

            // --- DRAG LOGIC ---
            function onPieceDragStart(e) {
                if (e.button !== 0) return;
                e.stopPropagation();
                pushUndo();

                activePiece = e.currentTarget;
                ghostPiece = activePiece.cloneNode(true);
                ghostPiece.classList.add('ghost');
                ghostPiece.removeAttribute('id');
                ghostPiece.style.transform = activePiece.style.transform;
                table.insertBefore(ghostPiece, activePiece);

                const rect = activePiece.getBoundingClientRect();
                const tableRect = table.getBoundingClientRect();

                activePiece.dataset.offsetX = e.clientX - rect.left;
                activePiece.dataset.offsetY = e.clientY - rect.top;

                anchorX = (rect.left - tableRect.left) + (rect.width / 2);
                anchorY = (rect.top - tableRect.top) + (rect.height / 2);
                showLine(anchorX, anchorY, anchorX, anchorY);
            }

            table.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return;
                if (e.target !== table && e.target !== document.getElementById('ui-layer')) return;
                isMeasuring = true;
                const tableRect = table.getBoundingClientRect();
                anchorX = e.clientX - tableRect.left;
                anchorY = e.clientY - tableRect.top;
                showLine(anchorX, anchorY, anchorX, anchorY);
            });

            function showLine(x1, y1, x2, y2) {
                const textEl = document.getElementById('measure-text');
                lineElement.style.opacity = 1;
                textEl.style.opacity = 1;
                lineElement.setAttribute('x1', x1);
                lineElement.setAttribute('y1', y1);
                lineElement.setAttribute('x2', x2);
                lineElement.setAttribute('y2', y2);
                textEl.innerHTML = '0"';
            }

            function onMouseMove(e) {
                if (!activePiece && !isMeasuring) return;

                const tableRect = table.getBoundingClientRect();
                let mouseX = e.clientX - tableRect.left;
                let mouseY = e.clientY - tableRect.top;
                let targetX = mouseX;
                let targetY = mouseY;

                if (activePiece) {
                    const offX = parseFloat(activePiece.dataset.offsetX);
                    const offY = parseFloat(activePiece.dataset.offsetY);
                    const newLeft = mouseX - offX;
                    const newTop = mouseY - offY;
                    activePiece.style.left = `${newLeft}px`;
                    activePiece.style.top = `${newTop}px`;

                    targetX = newLeft + (activePiece.offsetWidth / 2);
                    targetY = newTop + (activePiece.offsetHeight / 2);
                }

                if (anchorX > -1) {
                    lineElement.setAttribute('x2', targetX);
                    lineElement.setAttribute('y2', targetY);
                    const dx = targetX - anchorX;
                    const dy = targetY - anchorY;
                    const distancePx = Math.sqrt(dx * dx + dy * dy);

                    const textEl = document.getElementById('measure-text');
                    textEl.innerHTML = `${pxToInches(distancePx)}"`;
                    textEl.setAttribute('x', anchorX + (dx / 2) + 10);
                    textEl.setAttribute('y', anchorY + (dy / 2) - 10);
                } else {
                    const rect = activePiece.getBoundingClientRect();
                    anchorX = (rect.left - tableRect.left) + (rect.width / 2);
                    anchorY = (rect.top - tableRect.top) + (rect.height / 2);
                }
            }

            function onMouseUp(e) {
                if (activePiece) saveGame();

                activePiece = null;
                isMeasuring = false;
                if (ghostPiece) { ghostPiece.remove(); ghostPiece = null; }
                lineElement.style.opacity = 0;
                document.getElementById('measure-text').style.opacity = 0;
            }

            function onWheel(e) {
                e.preventDefault(); e.stopPropagation();
                pushUndo();
                const piece = e.currentTarget;
                let currentAngle = parseFloat(piece.dataset.angle) || 0;
                if (e.deltaY > 0) currentAngle += 15;
                else currentAngle -= 15;
                piece.dataset.angle = currentAngle;
                piece.style.transform = `rotate(${currentAngle}deg)`;
                saveGame();
            }

            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);

            initGame();

        </script>
    </body>

</html>