<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Wargame Prototype v6 (Synced)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background-color: #222;
            color: #ccc;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- RULES MODAL --- */
        .modal-overlay {
            display: none;
            /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            /* Sit on top of everything */
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #333;
            width: 800px;
            /* Made slightly wider for the doc */
            max-width: 90%;
            height: 80vh;
            /* Fixed height */
            border: 2px solid #666;
            box-shadow: 0 0 20px black;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 10px 15px;
            background: #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }

        /* Update this specific class */
        .modal-body {
            padding: 0;
            /* Remove padding so iframe fills space */
            overflow: hidden;
            /* Hide scrollbar on container, let iframe scroll */
            flex-grow: 1;
            background: white;
            /* Google Docs are white, this prevents dark flashes */
        }

        .close-btn {
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover {
            color: white;
        }

        #container {
            display: flex;
            gap: 20px;
        }

        /* --- SIDEBARS --- */
        .sidebar {
            width: 180px;
            background-color: #444;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 2px solid #555;
            text-align: center;
        }

        .palette-item {
            padding: 15px;
            font-weight: bold;
            color: white;
            cursor: grab;
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 5px;
        }

        .palette-item:hover {
            border-color: white;
        }

        /* --- BUTTONS --- */
        button {
            padding: 10px;
            cursor: pointer;
            border: none;
            color: white;
            font-weight: bold;
        }

        .btn-red {
            background-color: #d32f2f;
            border: 2px solid white;
        }

        .btn-red:active {
            background-color: #b71c1c;
        }

        .btn-grey {
            background-color: #666;
            color: #fff;
        }

        .btn-grey:active {
            background-color: #444;
        }

        .btn-blue {
            background-color: #1976d2;
            border: 1px solid #63a4ff;
        }

        .btn-blue:active {
            background-color: #0d47a1;
        }

        input[type="text"] {
            width: 90%;
            padding: 5px;
            margin-bottom: 5px;
            background: #222;
            border: 1px solid #555;
            color: white;
            text-align: center;
        }

        /* --- CONNECTION STATUS --- */
        #status-indicator {
            padding: 5px;
            font-size: 0.8em;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: #333;
            color: #888;
        }

        .status-connected {
            background-color: #2e7d32 !important;
            color: white !important;
        }

        /* --- TABLE --- */
        #game-table {
            position: relative;
            background-color: #35654d;
            /* Felt Green */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            cursor: crosshair;
        }

        /* --- PIECES --- */
        .piece {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            cursor: grab;
            transition: transform 0.1s ease-out;
        }

        .piece:active {
            cursor: grabbing;
        }

        .unit {
            font-weight: bold;
            font-size: 12px;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
            z-index: 10;
            background-color: #555;
            padding: 2px;
            line-height: 1.1;
        }

        .wound-marker {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #d32f2f;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
            display: none;
        }

        .terrain {
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            z-index: 5;
            opacity: 0.9;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .terrain.forest {
            background-color: #1b5e20;
            border: 2px dashed #4caf50;
            border-radius: 50%;
        }

        .terrain.hills {
            background-color: #795548;
            border: 2px solid #3e2723;
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
        }

        .terrain.rough {
            background-color: #9e9d24;
            border: 2px dotted #f0f4c3;
            border-radius: 20% 80% 40% 60% / 60% 40% 70% 30%;
        }

        /* --- VISUAL FX --- */
        .ghost {
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
        }

        .range-ring {
            position: absolute;
            border: 2px solid rgba(255, 0, 0, 0.6);
            background-color: rgba(255, 0, 0, 0.1);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
            transform: translate(-50%, -50%);
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        #measure-line {
            stroke: yellow;
            stroke-width: 3;
            stroke-dasharray: 10, 5;
            opacity: 0;
        }

        #measure-text {
            font-size: 18px;
            font-weight: bold;
            fill: yellow;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
        }

        #controls-hint {
            margin-top: auto;
            font-size: 0.8em;
            color: #888;
            text-align: left;
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="sidebar">
            <h3 style="margin-top:0">Multiplayer</h3>
            <div id="status-indicator">OFFLINE</div>
            <button id="host-btn" class="btn-blue" onclick="hostGame()">Host Game</button>
            <input type="text" id="my-id-display" placeholder="Your ID will appear here" readonly style="display:none;">
            <button id="copy-btn" class="btn-grey" onclick="copyId()" style="display:none; margin-bottom:10px;">Copy
                ID</button>
            <div style="border-top: 1px solid #666; margin: 5px 0;"></div>
            <input type="text" id="join-input" placeholder="Enter Host ID">
            <button id="join-btn" class="btn-blue" onclick="joinGame()">Join Game</button>
            <h3 style="margin-top:20px">Tools</h3>
            <button id="dice-btn" class="btn-red" onclick="rollDice()">Roll 2d6</button>
            <div id="dice-result">-</div>
            <div id="dice-detail"></div>
            <button class="btn-grey" onclick="openRulebook()" style="margin-top: 10px;">ðŸ“– Rulebook</button>
            <button onclick="undo()" class="btn-grey" style="margin-top: 15px;">Undo (Z)</button>
            <button onclick="resetGame()" class="btn-grey" style="margin-top: 5px;">Reset Board</button>
        </div>
        <div id="game-table">
            <svg id="ui-layer">
                <line id="measure-line" x1="0" y1="0" x2="0" y2="0" />
                <text id="measure-text" x="0" y="0">0"</text>
            </svg>
        </div>
        <div class="sidebar">
            <h3 style="margin-top:0">Terrain</h3>
            <div class="palette-item" style="background-color: #1b5e20;" onmousedown="spawnTerrain('forest')">Forest
            </div>
            <div class="palette-item" style="background-color: #795548;" onmousedown="spawnTerrain('hills')">Hills
            </div>
            <div class="palette-item" style="background-color: #9e9d24;" onmousedown="spawnTerrain('rough')">Rough
            </div>
            <div id="stats-panel" style="
                    width: 100%; 
                    background: #222; 
                    border: 1px solid #555; 
                    margin-top: 10px; 
                    padding: 10px;
                    box-sizing: border-box; 
                    display: flex; 
                    flex-direction: column; 
                    gap: 8px;
                    color: #ccc; 
                    font-family: monospace; 
                    font-size: 13px;
                    text-align: left;">
                <span style="color: #666; text-align: center;">Hover unit for stats</span>
            </div>
            <div id="controls-hint">
                <p><strong>Controls:</strong></p>
                <p>Drag to move</p>
                <p>Click Empty: Measure</p>
                <p>Mouse wheel to rotate unit or terrain</p>
                <p>Double click to rename unit</p>
                <!-- <p>Hover+R: Range (12")</p> -->
                <p>+/- over a unit to change wounds</p>
                <p>+/- over terrain to change size</p>
                <p>Z / Ctrl+Z: Undo</p>
            </div>
        </div>
    </div>
    <div id="rulebook-modal" class="modal-overlay" onclick="closeRulebook()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 style="margin:0; color:#fff;">Battlefield Rules</h2>
                <button class="btn-red" onclick="closeRulebook()" style="padding: 5px 10px;">X</button>
            </div>
            <div class="modal-body">
                <iframe id="rulebook-frame"
                    src="https://docs.google.com/document/d/e/2PACX-1vSET76CoLzTj6rVKhUUvukB41HHq0UD6K7QOIA_fNbdXbYRoelmxZQomHMqhIuGFlu-5TWF3_KOpjb7/pub?embedded=true"
                    style="width:100%; height:100%; border:none;">
                </iframe>
            </div>
        </div>
    </div>
    <script>
        // --- CONFIGURATION ---
        const SCALE = 20;
        const TABLE_WIDTH_FT = 4;
        const TABLE_DEPTH_FT = 3;
        const UNIT_WIDTH_MM = 88;
        const UNIT_DEPTH_MM = 63;
        const DEPLOY_INCHES = 6;
        const TERRAIN_DEFAULT_W = 6;
        const TERRAIN_DEFAULT_H = 4;
        const THREAT_RANGE_INCHES = 12;
        const SAVE_KEY = 'wargameSave_v6';

        // --- CONVERSIONS ---
        const mmToInches = (mm) => mm / 25.4;
        const inchesToPx = (inch) => inch * SCALE;
        const pxToInches = (px) => (px / SCALE).toFixed(1);

        const tableWidthPx = inchesToPx(TABLE_WIDTH_FT * 12);
        const tableHeightPx = inchesToPx(TABLE_DEPTH_FT * 12);
        const unitWidthPx = inchesToPx(mmToInches(UNIT_WIDTH_MM));
        const unitHeightPx = inchesToPx(mmToInches(UNIT_DEPTH_MM));

        // --- SETUP TABLE ---
        const table = document.getElementById('game-table');
        table.style.width = `${tableWidthPx}px`;
        table.style.height = `${tableHeightPx}px`;

        // --- PEERJS / NETWORK STATE ---
        let peer = null;
        let conn = null;
        let isHost = false;

        // --- GAME STATE ---
        let activePiece = null;
        let ghostPiece = null;
        let isMeasuring = false;
        let anchorX = 0;
        let anchorY = 0;
        let hoveredUnit = null;
        let hoveredTerrain = null;
        let undoStack = [];
        const MAX_UNDO = 20;

        const lineElement = document.getElementById('measure-line');

        // --- RULES LOGIC (IFRAME & TOOLTIPS) ---

        function openRulebook() {
            document.getElementById('rulebook-modal').style.display = 'flex';
        }

        function closeRulebook() {
            document.getElementById('rulebook-modal').style.display = 'none';
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeRulebook();
        });

        // FIXED: Defined this variable so the stats panel doesn't crash
        let globalRulesDB = [];

        // --- RULES DATA LOADER ---
        // Replace this URL with the CSV link for your "Rules" tab
        const RULES_CSV_URL = 'YOUR_RULES_CSV_URL_HERE';

        function loadRules() {
            Papa.parse("https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?gid=2000929092&single=true&output=csv", {
                download: true,
                header: false, // Set to false if you didn't add headers like "Rule, Description"
                skipEmptyLines: true,
                complete: function (results) {
                    // Map the CSV rows to our database
                    // Assuming Column A is Keyword, Column B is Rule Text
                    globalRulesDB = results.data.map(row => ({
                        keyword: row[0] ? row[0].trim() : "",
                        effect: row[1] ? row[1].trim() : ""
                    })).filter(r => r.keyword); // Remove empty rows

                    console.log("Rules loaded:", globalRulesDB.length);
                },
                error: function (err) {
                    console.log("No Rules CSV found (or error loading). Only manual 'Special' column will show.");
                }
            });
        }

        // Ensure this is called at startup
        loadRules();

        // --- STATS INTEGRATION ---
        const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?output=csv';

        let unitStatsDB = {};

        function loadStats() {
            Papa.parse(SHEET_URL, {
                download: true,
                header: true,
                skipEmptyLines: true,
                transformHeader: function (header) {
                    return header.trim();
                },
                complete: function (results) {
                    if (results.data.length > 0) {
                        console.log("CSV Headers Detected:", Object.keys(results.data[0]));
                    }
                    results.data.forEach(row => {
                        if (row.Unit) {
                            unitStatsDB[row.Unit.trim()] = row;
                        } else {
                            console.warn("Skipped row (Missing 'Unit' column):", row);
                        }
                    });
                    console.log("Stats loaded:", Object.keys(unitStatsDB).length, "units found.");
                },
                error: function (err) {
                    console.error("Error loading stats:", err);
                }
            });
        }

        function updateStatsPanel(unitName) {
            const panel = document.getElementById('stats-panel');
            if (!unitName) {
                panel.innerHTML = '<span style="color: #666; text-align: center;">Hover unit for stats</span>';
                return;
            }

            const cleanName = unitName.trim();
            const stats = unitStatsDB[cleanName];

            let activeRules = [];

            // Check Global Rules DB (Safety check added so it doesn't crash if empty)
            if (globalRulesDB.length > 0) {
                globalRulesDB.forEach(rule => {
                    if (cleanName.includes(rule.keyword)) {
                        activeRules.push(rule.effect);
                    }
                });
            }

            // Include "Special" column from main stats
            if (stats && stats.Special) {
                activeRules.push(stats.Special);
            }

            if (stats) {
                const rulesHtml = activeRules.length > 0
                    ? `<div style="margin-top:8px; padding-top:8px; border-top:1px solid #444;">
                             ${activeRules.map(r => `<div style="margin-bottom:4px; font-size:0.9em; color:#ddd;">â€¢ ${r}</div>`).join('')}
                           </div>`
                    : "";

                panel.innerHTML = `
                        <div style="font-weight:bold; color:white; border-bottom:1px solid #444; padding-bottom:4px; margin-bottom:4px;">
                            ${stats.Unit}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <span>Mv: <b style="color:#fff">${stats.Move}</b></span>
                            <span>Ra: <b style="color:#fff">${stats.Range}</b></span>
                            <span>Sh: <b style="color:#fff">${stats.Shoot}</b></span>
                            <span>St: <b style="color:#fff">${stats.Strike}</b></span>
                            <span>D: <b style="color:#fff">${stats.Defence}</b></span>
                        </div>
                        ${rulesHtml}
                    `;
            } else {
                panel.innerHTML = `<span style="color: #d32f2f;">Stats not found</span>`;
            }
        }

        loadStats();

        // --- NETWORKING FUNCTIONS ---

        function generateShortId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function hostGame() {
            if (peer) return;
            updateStatus("Initializing...");
            const shortId = generateShortId();
            peer = new Peer(shortId);

            peer.on('open', (id) => {
                updateStatus("Hosting");
                document.getElementById('my-id-display').style.display = 'block';
                document.getElementById('my-id-display').value = id;
                document.getElementById('copy-btn').style.display = 'block';
                document.getElementById('host-btn').style.display = 'none';
                document.getElementById('join-input').style.display = 'none';
                document.getElementById('join-btn').style.display = 'none';
                isHost = true;
            });

            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
                setTimeout(() => sendData({ type: 'SYNC_BOARD', payload: getBoardState() }), 500);
            });
            peer.on('error', (err) => {
                console.error(err);
                if (err.type === 'unavailable-id') {
                    peer = null;
                    hostGame();
                }
            });
        }

        function joinGame() {
            const hostId = document.getElementById('join-input').value.trim();
            if (!hostId) return alert("Enter a Host ID");
            updateStatus("Connecting...");
            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(hostId);
                setupConnection();
            });
            peer.on('error', (err) => {
                updateStatus("Error");
                alert("Could not connect. Check ID.");
            });
        }

        function setupConnection() {
            if (!conn) return;
            conn.on('open', () => {
                updateStatus("Connected!");
                document.getElementById('status-indicator').classList.add('status-connected');
            });
            conn.on('data', (data) => {
                handleIncomingData(data);
            });
            conn.on('close', () => {
                updateStatus("Disconnected");
                document.getElementById('status-indicator').classList.remove('status-connected');
                conn = null;
            });
        }

        function handleIncomingData(data) {
            if (data.type === 'SYNC_BOARD') {
                restoreBoardState(data.payload, true);
            }
            else if (data.type === 'ROLL_DICE') {
                document.getElementById('dice-result').innerText = data.result;
                document.getElementById('dice-detail').innerText = data.detail + " (Opponent)";
            }
        }

        function sendData(dataObj) {
            if (conn && conn.open) {
                conn.send(dataObj);
            }
        }

        function updateStatus(msg) {
            document.getElementById('status-indicator').innerText = msg;
        }

        function copyId() {
            const copyText = document.getElementById("my-id-display");
            copyText.select();
            navigator.clipboard.writeText(copyText.value);
            alert("ID Copied to Clipboard!");
        }

        // --- SERIALIZATION ---
        function getBoardState() {
            const pieces = [];
            document.querySelectorAll('.unit').forEach(el => {
                if (el.classList.contains('ghost')) return;
                pieces.push({
                    type: 'unit',
                    name: el.dataset.name,
                    x: parseFloat(el.style.left),
                    y: parseFloat(el.style.top),
                    angle: el.dataset.angle,
                    wounds: el.dataset.wounds,
                    color: el.style.backgroundColor
                });
            });
            document.querySelectorAll('.terrain').forEach(el => {
                pieces.push({
                    type: 'terrain',
                    subType: el.dataset.subType,
                    x: parseFloat(el.style.left),
                    y: parseFloat(el.style.top),
                    w: parseFloat(el.style.width),
                    h: parseFloat(el.style.height),
                    angle: el.dataset.angle
                });
            });
            return JSON.stringify(pieces);
        }

        function restoreBoardState(jsonString, suppressBroadcast = false) {
            if (!jsonString) return;
            table.querySelectorAll('.unit, .terrain, .ghost, .range-ring').forEach(p => p.remove());
            const data = JSON.parse(jsonString);
            data.forEach(obj => {
                if (obj.type === 'unit') {
                    createUnitDOM(obj.name, obj.color, obj.x, obj.y, obj.angle, obj.wounds);
                } else if (obj.type === 'terrain') {
                    createTerrainDOM(obj.subType, obj.x, obj.y, obj.w, obj.h, obj.angle);
                }
            });
            saveGame(suppressBroadcast);
        }

        function saveGame(suppressBroadcast = false) {
            const state = getBoardState();
            localStorage.setItem(SAVE_KEY, state);
            if (!suppressBroadcast) {
                sendData({ type: 'SYNC_BOARD', payload: state });
            }
        }

        // --- DOM FACTORIES ---
        function createUnitDOM(name, color, x, y, angle, wounds) {
            const div = document.createElement('div');
            div.classList.add('piece', 'unit');
            div.style.backgroundColor = color;
            div.style.width = `${unitWidthPx}px`;
            div.style.height = `${unitHeightPx}px`;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.innerText = name;
            div.dataset.name = name;
            div.dataset.angle = angle || 0;
            div.style.transform = `rotate(${angle}deg)`;
            div.dataset.wounds = wounds || 0;

            const appendMarker = () => {
                let marker = div.querySelector('.wound-marker');
                if (!marker) {
                    marker = document.createElement('div');
                    marker.classList.add('wound-marker');
                    div.appendChild(marker);
                }
                const w = div.dataset.wounds;
                marker.innerText = w;
                marker.style.display = (parseInt(w) > 0) ? 'flex' : 'none';
            };

            div.addEventListener('mouseenter', () => {
                hoveredUnit = div;
                updateStatsPanel(div.dataset.name);
            });

            div.addEventListener('mouseleave', () => {
                hoveredUnit = null;
                removeRangeRing();
                updateStatsPanel(null);
            });

            appendMarker();
            attachListeners(div);
            div.addEventListener('mouseenter', () => hoveredUnit = div);
            div.addEventListener('mouseleave', () => { hoveredUnit = null; removeRangeRing(); });

            div.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const currentName = div.dataset.name;
                const newName = prompt("Rename Unit:", currentName);
                if (newName !== null && newName.trim() !== "") {
                    pushUndo();
                    div.innerText = newName;
                    div.dataset.name = newName;
                    appendMarker();
                    saveGame();
                }
            });

            table.appendChild(div);
            return div;
        }

        function createTerrainDOM(subType, x, y, w, h, angle) {
            if (!subType || subType === "undefined") subType = "rough";
            const finalW = w || inchesToPx(TERRAIN_DEFAULT_W);
            const finalH = h || inchesToPx(TERRAIN_DEFAULT_H);

            const div = document.createElement('div');
            div.classList.add('piece', 'terrain', subType);
            div.innerText = subType.charAt(0).toUpperCase() + subType.slice(1);
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.style.width = `${finalW}px`;
            div.style.height = `${finalH}px`;
            div.dataset.subType = subType;
            div.dataset.angle = angle || 0;
            div.style.transform = `rotate(${angle}deg)`;

            attachListeners(div);
            div.addEventListener('mouseenter', () => hoveredTerrain = div);
            div.addEventListener('mouseleave', () => hoveredTerrain = null);

            table.appendChild(div);
            return div;
        }

        // --- GAME LOGIC ---
        function pushUndo() {
            if (undoStack.length >= MAX_UNDO) undoStack.shift();
            undoStack.push(getBoardState());
        }

        window.undo = function () {
            if (undoStack.length === 0) return;
            const previousState = undoStack.pop();
            restoreBoardState(previousState);
        };

        window.resetGame = function () {
            if (confirm("Reset board?")) {
                localStorage.removeItem(SAVE_KEY);
                location.reload();
            }
        };

        function rollDice() {
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            const total = d1 + d2;
            const detail = `(${d1} + ${d2})`;
            document.getElementById('dice-result').innerText = total;
            document.getElementById('dice-detail').innerText = detail;
            sendData({ type: 'ROLL_DICE', result: total, detail: detail });
        }

        function initGame() {
            const saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                restoreBoardState(saved, true);
            } else {
                createDefaultUnits();
                createDefaultTerrain();
                saveGame(true);
            }
        }

        function createDefaultUnits() {
            const sides = ['red', 'blue'];
            const deployYPositions = [inchesToPx(DEPLOY_INCHES), tableHeightPx - inchesToPx(DEPLOY_INCHES)];

            const races = ["Elf", "Human", "Orc", "Dwarf", "Undead"];
            const types = ["Archers", "Swords", "Spears", "Cavalry", "Skirmishers", "Mounted Bowmen"];

            sides.forEach((color, sideIndex) => {
                const yPos = deployYPositions[sideIndex];
                const spacing = tableWidthPx / 7;
                const initialAngle = (sideIndex === 0) ? 180 : 0;

                // Generate all possible combinations
                let deck = [];
                races.forEach(race => {
                    types.forEach(type => {
                        deck.push(`${race} ${type}`);
                    });
                });

                // Shuffle deck (Fisher-Yates)
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Slice the first 6 unique units
                const unitNames = deck.slice(0, 6);

                unitNames.forEach((name, i) => {
                    const x = (spacing * (i + 1)) - (unitWidthPx / 2);
                    const y = yPos - (unitHeightPx / 2);
                    createUnitDOM(name, color, x, y, initialAngle, 0);
                });
            });
        }

        function createDefaultTerrain() {
            const terrainTypes = ['forest', 'forest', 'hills', 'hills', 'rough', 'rough'];
            terrainTypes.forEach((type) => {
                const w = inchesToPx(TERRAIN_DEFAULT_W);
                const h = inchesToPx(TERRAIN_DEFAULT_H);
                const x = Math.random() * (tableWidthPx - w - 100) + 50;
                const y = Math.random() * (inchesToPx(26) - inchesToPx(10)) + inchesToPx(10);
                const angle = Math.floor(Math.random() * 360);
                createTerrainDOM(type, x, y, w, h, angle);
            });
        }

        window.spawnTerrain = function (type) {
            pushUndo();
            const w = inchesToPx(TERRAIN_DEFAULT_W);
            const h = inchesToPx(TERRAIN_DEFAULT_H);
            const div = createTerrainDOM(type, -9999, -9999, w, h, 0);
            activePiece = div;
            ghostPiece = null;
            anchorX = -1;
            div.dataset.offsetX = w / 2;
            div.dataset.offsetY = h / 2;
            saveGame();
        };

        function attachListeners(element) {
            element.addEventListener('mousedown', onPieceDragStart);
            element.addEventListener('wheel', onWheel);
        }

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
            if (e.key === 'z') { undo(); return; }
            if (e.key.toLowerCase() === 'r' && hoveredUnit) showRangeRing(hoveredUnit);

            const isPlus = (e.key === '+' || e.key === '=' || e.code === 'NumpadAdd');
            const isMinus = (e.key === '-' || e.key === '_' || e.code === 'NumpadSubtract');

            // Rotation Keys
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const target = activePiece || hoveredUnit || hoveredTerrain;
                if (target) {
                    e.preventDefault();
                    pushUndo();
                    let currentAngle = parseFloat(target.dataset.angle) || 0;
                    const step = e.shiftKey ? 1 : 15;
                    if (e.key === 'ArrowRight') currentAngle += step;
                    else currentAngle -= step;
                    target.dataset.angle = currentAngle;
                    target.style.transform = `rotate(${currentAngle}deg)`;
                    saveGame();
                    return;
                }
            }

            if (!isPlus && !isMinus) return;

            pushUndo();

            if (hoveredUnit) {
                let wounds = parseInt(hoveredUnit.dataset.wounds);
                const marker = hoveredUnit.querySelector('.wound-marker');
                if (isPlus) wounds++;
                if (isMinus && wounds > 0) wounds--;
                hoveredUnit.dataset.wounds = wounds;
                marker.innerText = wounds;
                marker.style.display = (wounds > 0) ? 'flex' : 'none';
            }
            else if (hoveredTerrain) {
                let w = parseFloat(hoveredTerrain.style.width);
                let h = parseFloat(hoveredTerrain.style.height);
                const factor = isPlus ? 1.1 : 0.9;
                hoveredTerrain.style.width = `${w * factor}px`;
                hoveredTerrain.style.height = `${h * factor}px`;
            }
            saveGame();
        });

        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'r') removeRangeRing();
        });

        function showRangeRing(unit) {
            if (unit.querySelector('.range-ring')) return;
            const ring = document.createElement('div');
            ring.classList.add('range-ring');
            const diameterPx = inchesToPx(THREAT_RANGE_INCHES * 2);
            ring.style.width = `${diameterPx}px`;
            ring.style.height = `${diameterPx}px`;
            ring.style.left = '50%';
            ring.style.top = '50%';
            unit.appendChild(ring);
        }
        function removeRangeRing() {
            document.querySelectorAll('.range-ring').forEach(r => r.remove());
        }

        // --- DRAG LOGIC ---
        function onPieceDragStart(e) {
            if (e.button !== 0) return;
            e.stopPropagation();
            pushUndo();
            activePiece = e.currentTarget;
            ghostPiece = activePiece.cloneNode(true);
            ghostPiece.classList.add('ghost');
            ghostPiece.removeAttribute('id');
            ghostPiece.style.transform = activePiece.style.transform;
            table.insertBefore(ghostPiece, activePiece);
            const rect = activePiece.getBoundingClientRect();
            const tableRect = table.getBoundingClientRect();
            activePiece.dataset.offsetX = e.clientX - rect.left;
            activePiece.dataset.offsetY = e.clientY - rect.top;
            anchorX = (rect.left - tableRect.left) + (rect.width / 2);
            anchorY = (rect.top - tableRect.top) + (rect.height / 2);
            showLine(anchorX, anchorY, anchorX, anchorY);
        }

        table.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (e.target !== table && e.target !== document.getElementById('ui-layer')) return;
            isMeasuring = true;
            const tableRect = table.getBoundingClientRect();
            anchorX = e.clientX - tableRect.left;
            anchorY = e.clientY - tableRect.top;
            showLine(anchorX, anchorY, anchorX, anchorY);
        });

        function showLine(x1, y1, x2, y2) {
            const textEl = document.getElementById('measure-text');
            lineElement.style.opacity = 1;
            textEl.style.opacity = 1;
            lineElement.setAttribute('x1', x1);
            lineElement.setAttribute('y1', y1);
            lineElement.setAttribute('x2', x2);
            lineElement.setAttribute('y2', y2);
            textEl.innerHTML = '0"';
        }

        function onMouseMove(e) {
            if (!activePiece && !isMeasuring) return;
            const tableRect = table.getBoundingClientRect();
            let mouseX = e.clientX - tableRect.left;
            let mouseY = e.clientY - tableRect.top;
            let targetX = mouseX;
            let targetY = mouseY;

            if (activePiece) {
                const offX = parseFloat(activePiece.dataset.offsetX);
                const offY = parseFloat(activePiece.dataset.offsetY);
                const newLeft = mouseX - offX;
                const newTop = mouseY - offY;
                activePiece.style.left = `${newLeft}px`;
                activePiece.style.top = `${newTop}px`;
                targetX = newLeft + (activePiece.offsetWidth / 2);
                targetY = newTop + (activePiece.offsetHeight / 2);
            }

            if (anchorX > -1) {
                lineElement.setAttribute('x2', targetX);
                lineElement.setAttribute('y2', targetY);
                const dx = targetX - anchorX;
                const dy = targetY - anchorY;
                const distancePx = Math.sqrt(dx * dx + dy * dy);
                const textEl = document.getElementById('measure-text');
                textEl.innerHTML = `${pxToInches(distancePx)}"`;
                textEl.setAttribute('x', anchorX + (dx / 2) + 10);
                textEl.setAttribute('y', anchorY + (dy / 2) - 10);
            } else {
                const rect = activePiece.getBoundingClientRect();
                anchorX = (rect.left - tableRect.left) + (rect.width / 2);
                anchorY = (rect.top - tableRect.top) + (rect.height / 2);
            }
        }

        function onMouseUp(e) {
            if (activePiece) saveGame();
            activePiece = null;
            isMeasuring = false;
            if (ghostPiece) { ghostPiece.remove(); ghostPiece = null; }
            lineElement.style.opacity = 0;
            document.getElementById('measure-text').style.opacity = 0;
        }

        function onWheel(e) {
            e.preventDefault(); e.stopPropagation();
            pushUndo();
            const piece = e.currentTarget;
            let currentAngle = parseFloat(piece.dataset.angle) || 0;
            if (e.deltaY > 0) currentAngle += 15;
            else currentAngle -= 15;
            piece.dataset.angle = currentAngle;
            piece.style.transform = `rotate(${currentAngle}deg)`;
            saveGame();
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        initGame();

    </script>
</body>

</html>