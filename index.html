<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Wargame Prototype v6 (Synced)</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: sans-serif;
            background-color: #222;
            color: #ccc;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- RULES MODAL --- */
        .modal-overlay {
            display: none;
            /* Hidden by default */
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            /* Sit on top of everything */
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #333;
            width: 800px;
            /* Made slightly wider for the doc */
            max-width: 90%;
            height: 80vh;
            /* Fixed height */
            border: 2px solid #666;
            box-shadow: 0 0 20px black;
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 10px 15px;
            background: #222;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
        }

        /* Update this specific class */
        .modal-body {
            padding: 0;
            /* Remove padding so iframe fills space */
            overflow: hidden;
            /* Hide scrollbar on container, let iframe scroll */
            flex-grow: 1;
            background: white;
            /* Google Docs are white, this prevents dark flashes */
        }

        .close-btn {
            color: #aaa;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover {
            color: white;
        }

        #container {
            display: flex;
            gap: 20px;
        }

        /* --- SIDEBARS --- */
        .sidebar {
            width: 180px;
            background-color: #444;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border: 2px solid #555;
            text-align: center;
        }

        .palette-item {
            padding: 15px;
            font-weight: bold;
            color: white;
            cursor: grab;
            border: 2px solid rgba(255, 255, 255, 0.2);
            margin-bottom: 5px;
        }

        .palette-item:hover {
            border-color: white;
        }

        /* --- BUTTONS --- */
        button {
            padding: 10px;
            cursor: pointer;
            border: none;
            color: white;
            font-weight: bold;
        }

        .btn-red {
            background-color: #d32f2f;
            border: 2px solid white;
        }

        .btn-red:active {
            background-color: #b71c1c;
        }

        .btn-grey {
            background-color: #666;
            color: #fff;
        }

        .btn-grey:active {
            background-color: #444;
        }

        .btn-blue {
            background-color: #1976d2;
            border: 1px solid #63a4ff;
        }

        .btn-blue:active {
            background-color: #0d47a1;
        }

        input[type="text"] {
            width: 90%;
            padding: 5px;
            margin-bottom: 5px;
            background: #222;
            border: 1px solid #555;
            color: white;
            text-align: center;
        }

        /* --- CONNECTION STATUS --- */
        #status-indicator {
            padding: 5px;
            font-size: 0.8em;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: #333;
            color: #888;
        }

        .status-connected {
            background-color: #2e7d32 !important;
            color: white !important;
        }

        /* --- TABLE --- */
        #game-table {
            position: relative;
            background-color: #35654d;
            /* Felt Green */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            cursor: crosshair;
        }

        /* --- PIECES --- */
        .piece {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            box-sizing: border-box;
            cursor: grab;
            transition: transform 0.1s ease-out;
        }

        .piece:active {
            cursor: grabbing;
        }

        .unit {
            font-weight: bold;
            font-size: 12px;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.8);
            z-index: 10;
            background-color: #555;
            padding: 2px;
            line-height: 1.1;
        }

        .wound-marker {
            position: absolute;
            top: -10px;
            right: -10px;
            background-color: #d32f2f;
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 15;
            display: none;
        }

        .terrain {
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            z-index: 5;
            opacity: 0.9;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .terrain.forest {
            background-color: #1b5e20;
            border: 2px dashed #4caf50;
            border-radius: 50%;
        }

        .terrain.hills {
            background-color: #795548;
            border: 2px solid #3e2723;
            border-radius: 30% 70% 70% 30% / 30% 30% 70% 70%;
        }

        .terrain.rough {
            background-color: #9e9d24;
            border: 2px dotted #f0f4c3;
            border-radius: 20% 80% 40% 60% / 60% 40% 70% 30%;
        }

        /* --- VISUAL FX --- */
        .ghost {
            opacity: 0.3;
            pointer-events: none;
            z-index: 1;
        }

        .range-ring {
            position: absolute;
            border: 2px solid rgba(255, 0, 0, 0.6);
            background-color: rgba(255, 0, 0, 0.1);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
            transform: translate(-50%, -50%);
        }

        /* --- UI LAYER --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        #measure-line {
            stroke: yellow;
            stroke-width: 3;
            stroke-dasharray: 10, 5;
            opacity: 0;
        }

        #measure-text {
            font-size: 18px;
            font-weight: bold;
            fill: yellow;
            text-shadow: 1px 1px 2px black;
            opacity: 0;
        }

        #controls-hint {
            margin-top: auto;
            font-size: 0.8em;
            color: #888;
            text-align: left;
        }

        /* --- MOBILE / CAMERA UI --- */
        #viewport {
            position: relative;
            flex-grow: 1;
            overflow: hidden;
            background-color: #111;
            display: flex;
            /* Center the table visually if zoomed out? Optional. */
            justify-content: center;
            align-items: center;
            /* Prevent default touch actions like browser scroll/zoom */
            touch-action: none;
        }

        /* Override table position for camera transform */
        #game-table {
            transform-origin: 0 0;
            /* Scaling from top-left makes math easier usually, or center. 0 0 is standard for matrix transforms */
            /* position: absolute;  <-- We might want this if we pan freely */
            flex-shrink: 0;
            /* Don't shrink flex item */
        }

        /* Selection Ring */
        .selection-ring {
            position: absolute;
            border: 2px dashed #00ffff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            transform: translate(-50%, -50%);
            display: none;
        }

        .rotate-handle {
            position: absolute;
            top: -15px;
            /* stick out top */
            left: 50%;
            width: 20px;
            height: 20px;
            background: #00ffff;
            border-radius: 50%;
            transform: translateX(-50%);
            cursor: grab;
            pointer-events: auto;
            /* Handle needs to be clickable */
        }

        /* Wound Buttons */
        .wound-controls {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 140%;
            /* wider than unit */
            height: 40px;
            transform: translate(-50%, -50%);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            /* Let clicks pass through to unit primarily? or icons need click */
        }

        .wound-btn {
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 1px solid white;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            font-weight: bold;
            pointer-events: auto;
            cursor: pointer;
        }

        /* Stats Popover */
        .stats-popover {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #999;
            padding: 10px;
            color: white;
            z-index: 200;
            border-radius: 8px;
            pointer-events: none;
            /* Click through to dismiss? */
            display: none;
            max-width: 200px;
            font-size: 14px;
            text-align: left;
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="sidebar">
            <h3 style="margin-top:0">Multiplayer</h3>
            <div id="status-indicator">OFFLINE</div>
            <button id="host-btn" class="btn-blue" onclick="hostGame()">Host Game</button>
            <input type="text" id="my-id-display" placeholder="Your ID will appear here" readonly style="display:none;">
            <button id="copy-btn" class="btn-grey" onclick="copyId()" style="display:none; margin-bottom:10px;">Copy
                ID</button>
            <div style="border-top: 1px solid #666; margin: 5px 0;"></div>
            <input type="text" id="join-input" placeholder="Enter Host ID">
            <button id="join-btn" class="btn-blue" onclick="joinGame()">Join Game</button>
            <h3 style="margin-top:20px">Tools</h3>
            <button id="dice-btn" class="btn-red" onclick="rollDice()">Roll 2d6</button>
            <div id="dice-result">-</div>
            <div id="dice-detail"></div>
            <button class="btn-grey" onclick="openRulebook()" style="margin-top: 10px;">ðŸ“– Rulebook</button>
            <button onclick="undo()" class="btn-grey" style="margin-top: 15px;">Undo (Z)</button>
            <button onclick="resetGame()" class="btn-grey" style="margin-top: 5px;">Reset Board</button>
        </div>
        <div id="viewport">
            <div id="game-table">
                <svg id="ui-layer">
                    <line id="measure-line" x1="0" y1="0" x2="0" y2="0" />
                    <text id="measure-text" x="0" y="0">0"</text>
                </svg>
                <!-- Floating Selection UI (Single instance moved around) -->
                <div id="selection-ui" class="selection-ring">
                    <div class="rotate-handle" id="rotate-handle"></div>
                    <div class="wound-controls">
                        <div class="wound-btn" id="btn-minus">-</div>
                        <div class="wound-btn" id="btn-plus">+</div>
                    </div>
                </div>
                <!-- Stats Popup -->
                <div id="stats-popover" class="stats-popover"></div>
            </div>
        </div>
        <div class="sidebar">
            <h3 style="margin-top:0">Terrain</h3>
            <div class="palette-item" style="background-color: #1b5e20;" onmousedown="spawnTerrain('forest')">Forest
            </div>
            <div class="palette-item" style="background-color: #795548;" onmousedown="spawnTerrain('hills')">Hills
            </div>
            <div class="palette-item" style="background-color: #9e9d24;" onmousedown="spawnTerrain('rough')">Rough
            </div>
            <div id="stats-panel" style="
                    width: 100%; 
                    background: #222; 
                    border: 1px solid #555; 
                    margin-top: 10px; 
                    padding: 10px;
                    box-sizing: border-box; 
                    display: flex; 
                    flex-direction: column; 
                    gap: 8px;
                    color: #ccc; 
                    font-family: monospace; 
                    font-size: 13px;
                    text-align: left;">
                <span style="color: #666; text-align: center;">Hover unit for stats</span>
            </div>
            <div id="controls-hint">
                <p><strong>Controls:</strong></p>
                <p>Drag to move</p>
                <p>Click Empty: Measure</p>
                <p>Mouse wheel to rotate unit or terrain</p>
                <p>Double click to rename unit</p>
                <!-- <p>Hover+R: Range (12")</p> -->
                <p>+/- over a unit to change wounds</p>
                <p>+/- over terrain to change size</p>
                <p>Z / Ctrl+Z: Undo</p>
            </div>
        </div>
    </div>
    <div id="rulebook-modal" class="modal-overlay" onclick="closeRulebook()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h2 style="margin:0; color:#fff;">Battlefield Rules</h2>
                <button class="btn-red" onclick="closeRulebook()" style="padding: 5px 10px;">X</button>
            </div>
            <div class="modal-body">
                <iframe id="rulebook-frame"
                    src="https://docs.google.com/document/d/e/2PACX-1vSET76CoLzTj6rVKhUUvukB41HHq0UD6K7QOIA_fNbdXbYRoelmxZQomHMqhIuGFlu-5TWF3_KOpjb7/pub?embedded=true"
                    style="width:100%; height:100%; border:none;">
                </iframe>
            </div>
        </div>
    </div>
    <script>
        // --- CONFIGURATION ---
        const SCALE = 20;
        const TABLE_WIDTH_FT = 4;
        const TABLE_DEPTH_FT = 3;
        const UNIT_WIDTH_MM = 88;
        const UNIT_DEPTH_MM = 63;
        const DEPLOY_INCHES = 6;
        const TERRAIN_DEFAULT_W = 6;
        const TERRAIN_DEFAULT_H = 4;
        const THREAT_RANGE_INCHES = 12;
        const SAVE_KEY = 'wargameSave_v6';

        // --- CONVERSIONS ---
        const mmToInches = (mm) => mm / 25.4;
        const inchesToPx = (inch) => inch * SCALE;
        const pxToInches = (px) => (px / SCALE).toFixed(1);

        const tableWidthPx = inchesToPx(TABLE_WIDTH_FT * 12);
        const tableHeightPx = inchesToPx(TABLE_DEPTH_FT * 12);
        const unitWidthPx = inchesToPx(mmToInches(UNIT_WIDTH_MM));
        const unitHeightPx = inchesToPx(mmToInches(UNIT_DEPTH_MM));

        // --- SETUP TABLE ---
        const table = document.getElementById('game-table');
        table.style.width = `${tableWidthPx}px`;
        table.style.height = `${tableHeightPx}px`;

        // --- PEERJS / NETWORK STATE ---
        let peer = null;
        let conn = null;
        let isHost = false;

        // --- GAME STATE ---
        let activePiece = null;
        let ghostPiece = null;
        let isMeasuring = false;
        let anchorX = 0;
        let anchorY = 0;
        let hoveredUnit = null;
        let hoveredTerrain = null;
        let undoStack = [];
        const MAX_UNDO = 20;

        // --- CAMERA STATE ---
        let camera = { x: 0, y: 0, scale: 1.0 };
        const VIEWPORT = document.getElementById('viewport');

        const lineElement = document.getElementById('measure-line');

        function updateCameraTransform() {
            const t = document.getElementById('game-table');
            t.style.transform = `translate(${camera.x}px, ${camera.y}px) scale(${camera.scale})`;
        }

        function getPointerPos(e) {
            // Handle Touch or Mouse
            const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX :
                (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0].clientX : e.clientX;
            const clientY = (e.touches && e.touches.length > 0) ? e.touches[0].clientY :
                (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0].clientY : e.clientY;

            if (clientX === undefined) return { x: 0, y: 0 }; // Fallback

            const rect = VIEWPORT.getBoundingClientRect();
            const vx = clientX - rect.left;
            const vy = clientY - rect.top;

            return {
                x: (vx - camera.x) / camera.scale,
                y: (vy - camera.y) / camera.scale
            };
        }

        // --- RULES LOGIC (IFRAME & TOOLTIPS) ---

        function openRulebook() {
            document.getElementById('rulebook-modal').style.display = 'flex';
        }

        function closeRulebook() {
            document.getElementById('rulebook-modal').style.display = 'none';
        }

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') closeRulebook();
        });

        // FIXED: Defined this variable so the stats panel doesn't crash
        let globalRulesDB = [];

        // --- RULES DATA LOADER ---
        // Replace this URL with the CSV link for your "Rules" tab
        const RULES_CSV_URL = 'YOUR_RULES_CSV_URL_HERE';

        function loadRules() {
            Papa.parse("https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?gid=2000929092&single=true&output=csv", {
                download: true,
                header: false, // Set to false if you didn't add headers like "Rule, Description"
                skipEmptyLines: true,
                complete: function (results) {
                    // Map the CSV rows to our database
                    // Assuming Column A is Keyword, Column B is Rule Text
                    globalRulesDB = results.data.map(row => ({
                        keyword: row[0] ? row[0].trim() : "",
                        effect: row[1] ? row[1].trim() : ""
                    })).filter(r => r.keyword); // Remove empty rows

                    console.log("Rules loaded:", globalRulesDB.length);
                },
                error: function (err) {
                    console.log("No Rules CSV found (or error loading). Only manual 'Special' column will show.");
                }
            });
        }

        // Ensure this is called at startup
        loadRules();

        // --- STATS INTEGRATION ---
        const SHEET_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQXT5eF4DzRhJokOVdTb5g1Lnt6_gFkeh7oEdg2DLYAtY98FxybE-ijwA8uoWDiYtiBb0a3BM-ukWx9/pub?output=csv';

        let unitStatsDB = {};

        function loadStats() {
            Papa.parse(SHEET_URL, {
                download: true,
                header: true,
                skipEmptyLines: true,
                transformHeader: function (header) {
                    return header.trim();
                },
                complete: function (results) {
                    if (results.data.length > 0) {
                        console.log("CSV Headers Detected:", Object.keys(results.data[0]));
                    }
                    results.data.forEach(row => {
                        if (row.Unit) {
                            unitStatsDB[row.Unit.trim()] = row;
                        } else {
                            console.warn("Skipped row (Missing 'Unit' column):", row);
                        }
                    });
                    console.log("Stats loaded:", Object.keys(unitStatsDB).length, "units found.");
                },
                error: function (err) {
                    console.error("Error loading stats:", err);
                }
            });
        }

        function updateStatsPanel(unitName) {
            const panel = document.getElementById('stats-panel');
            if (!unitName) {
                panel.innerHTML = '<span style="color: #666; text-align: center;">Hover unit for stats</span>';
                return;
            }

            const cleanName = unitName.trim();
            const stats = unitStatsDB[cleanName];

            let activeRules = [];

            // Check Global Rules DB (Safety check added so it doesn't crash if empty)
            if (globalRulesDB.length > 0) {
                globalRulesDB.forEach(rule => {
                    if (cleanName.includes(rule.keyword)) {
                        activeRules.push(rule.effect);
                    }
                });
            }

            // Include "Special" column from main stats
            if (stats && stats.Special) {
                activeRules.push(stats.Special);
            }

            if (stats) {
                const rulesHtml = activeRules.length > 0
                    ? `<div style="margin-top:8px; padding-top:8px; border-top:1px solid #444;">
                             ${activeRules.map(r => `<div style="margin-bottom:4px; font-size:0.9em; color:#ddd;">â€¢ ${r}</div>`).join('')}
                           </div>`
                    : "";

                panel.innerHTML = `
                        <div style="font-weight:bold; color:white; border-bottom:1px solid #444; padding-bottom:4px; margin-bottom:4px;">
                            ${stats.Unit}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <span>Mv: <b style="color:#fff">${stats.Move}</b></span>
                            <span>Ra: <b style="color:#fff">${stats.Range}</b></span>
                            <span>Sh: <b style="color:#fff">${stats.Shoot}</b></span>
                            <span>St: <b style="color:#fff">${stats.Strike}</b></span>
                            <span>D: <b style="color:#fff">${stats.Defence}</b></span>
                        </div>
                        ${rulesHtml}
                    `;
            } else {
                panel.innerHTML = `<span style="color: #d32f2f;">Stats not found</span>`;
            }
        }

        loadStats();

        // --- NETWORKING FUNCTIONS ---

        function generateShortId() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            let result = '';
            for (let i = 0; i < 4; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        function hostGame() {
            if (peer) return;
            updateStatus("Initializing...");
            const shortId = generateShortId();
            peer = new Peer(shortId);

            peer.on('open', (id) => {
                updateStatus("Hosting");
                document.getElementById('my-id-display').style.display = 'block';
                document.getElementById('my-id-display').value = id;
                document.getElementById('copy-btn').style.display = 'block';
                document.getElementById('host-btn').style.display = 'none';
                document.getElementById('join-input').style.display = 'none';
                document.getElementById('join-btn').style.display = 'none';
                isHost = true;
            });

            peer.on('connection', (c) => {
                conn = c;
                setupConnection();
                setTimeout(() => sendData({ type: 'SYNC_BOARD', payload: getBoardState() }), 500);
            });
            peer.on('error', (err) => {
                console.error(err);
                if (err.type === 'unavailable-id') {
                    peer = null;
                    hostGame();
                }
            });
        }

        function joinGame() {
            const hostId = document.getElementById('join-input').value.trim();
            if (!hostId) return alert("Enter a Host ID");
            updateStatus("Connecting...");
            peer = new Peer();
            peer.on('open', () => {
                conn = peer.connect(hostId);
                setupConnection();
            });
            peer.on('error', (err) => {
                updateStatus("Error");
                alert("Could not connect. Check ID.");
            });
        }

        function setupConnection() {
            if (!conn) return;
            conn.on('open', () => {
                updateStatus("Connected!");
                document.getElementById('status-indicator').classList.add('status-connected');
            });
            conn.on('data', (data) => {
                handleIncomingData(data);
            });
            conn.on('close', () => {
                updateStatus("Disconnected");
                document.getElementById('status-indicator').classList.remove('status-connected');
                conn = null;
            });
        }

        function handleIncomingData(data) {
            if (data.type === 'SYNC_BOARD') {
                restoreBoardState(data.payload, true);
            }
            else if (data.type === 'ROLL_DICE') {
                document.getElementById('dice-result').innerText = data.result;
                document.getElementById('dice-detail').innerText = data.detail + " (Opponent)";
            }
        }

        function sendData(dataObj) {
            if (conn && conn.open) {
                conn.send(dataObj);
            }
        }

        function updateStatus(msg) {
            document.getElementById('status-indicator').innerText = msg;
        }

        function copyId() {
            const copyText = document.getElementById("my-id-display");
            copyText.select();
            navigator.clipboard.writeText(copyText.value);
            alert("ID Copied to Clipboard!");
        }

        // --- SERIALIZATION ---
        function getBoardState() {
            const pieces = [];
            document.querySelectorAll('.unit').forEach(el => {
                if (el.classList.contains('ghost')) return;
                pieces.push({
                    type: 'unit',
                    name: el.dataset.name,
                    x: parseFloat(el.style.left),
                    y: parseFloat(el.style.top),
                    angle: el.dataset.angle,
                    wounds: el.dataset.wounds,
                    color: el.style.backgroundColor
                });
            });
            document.querySelectorAll('.terrain').forEach(el => {
                pieces.push({
                    type: 'terrain',
                    subType: el.dataset.subType,
                    x: parseFloat(el.style.left),
                    y: parseFloat(el.style.top),
                    w: parseFloat(el.style.width),
                    h: parseFloat(el.style.height),
                    angle: el.dataset.angle
                });
            });
            return JSON.stringify(pieces);
        }

        function restoreBoardState(jsonString, suppressBroadcast = false) {
            if (!jsonString) return;
            table.querySelectorAll('.unit, .terrain, .ghost, .range-ring').forEach(p => p.remove());
            const data = JSON.parse(jsonString);
            data.forEach(obj => {
                if (obj.type === 'unit') {
                    createUnitDOM(obj.name, obj.color, obj.x, obj.y, obj.angle, obj.wounds);
                } else if (obj.type === 'terrain') {
                    createTerrainDOM(obj.subType, obj.x, obj.y, obj.w, obj.h, obj.angle);
                }
            });
            saveGame(suppressBroadcast);
        }

        function saveGame(suppressBroadcast = false) {
            const state = getBoardState();
            localStorage.setItem(SAVE_KEY, state);
            if (!suppressBroadcast) {
                sendData({ type: 'SYNC_BOARD', payload: state });
            }
        }

        // --- DOM FACTORIES ---
        function createUnitDOM(name, color, x, y, angle, wounds) {
            const div = document.createElement('div');
            div.classList.add('piece', 'unit');
            div.style.backgroundColor = color;
            div.style.width = `${unitWidthPx}px`;
            div.style.height = `${unitHeightPx}px`;
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.innerText = name;
            div.dataset.name = name;
            div.dataset.angle = angle || 0;
            div.style.transform = `rotate(${angle}deg)`;
            div.dataset.wounds = wounds || 0;

            const appendMarker = () => {
                let marker = div.querySelector('.wound-marker');
                if (!marker) {
                    marker = document.createElement('div');
                    marker.classList.add('wound-marker');
                    div.appendChild(marker);
                }
                const w = div.dataset.wounds;
                marker.innerText = w;
                marker.style.display = (parseInt(w) > 0) ? 'flex' : 'none';
            };

            div.addEventListener('mouseenter', () => {
                hoveredUnit = div;
                updateStatsPanel(div.dataset.name);
            });

            div.addEventListener('mouseleave', () => {
                hoveredUnit = null;
                removeRangeRing();
                updateStatsPanel(null);
            });

            appendMarker();
            attachListeners(div);
            div.addEventListener('mouseenter', () => hoveredUnit = div);
            div.addEventListener('mouseleave', () => { hoveredUnit = null; removeRangeRing(); });

            div.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                const currentName = div.dataset.name;
                const newName = prompt("Rename Unit:", currentName);
                if (newName !== null && newName.trim() !== "") {
                    pushUndo();
                    div.innerText = newName;
                    div.dataset.name = newName;
                    appendMarker();
                    saveGame();
                }
            });

            table.appendChild(div);
            return div;
        }

        function createTerrainDOM(subType, x, y, w, h, angle) {
            if (!subType || subType === "undefined") subType = "rough";
            const finalW = w || inchesToPx(TERRAIN_DEFAULT_W);
            const finalH = h || inchesToPx(TERRAIN_DEFAULT_H);

            const div = document.createElement('div');
            div.classList.add('piece', 'terrain', subType);
            div.innerText = subType.charAt(0).toUpperCase() + subType.slice(1);
            div.style.left = `${x}px`;
            div.style.top = `${y}px`;
            div.style.width = `${finalW}px`;
            div.style.height = `${finalH}px`;
            div.dataset.subType = subType;
            div.dataset.angle = angle || 0;
            div.style.transform = `rotate(${angle}deg)`;

            attachListeners(div);
            div.addEventListener('mouseenter', () => hoveredTerrain = div);
            div.addEventListener('mouseleave', () => hoveredTerrain = null);

            table.appendChild(div);
            return div;
        }

        // --- GAME LOGIC ---
        function pushUndo() {
            if (undoStack.length >= MAX_UNDO) undoStack.shift();
            undoStack.push(getBoardState());
        }

        window.undo = function () {
            if (undoStack.length === 0) return;
            const previousState = undoStack.pop();
            restoreBoardState(previousState);
        };

        window.resetGame = function () {
            if (confirm("Reset board?")) {
                localStorage.removeItem(SAVE_KEY);
                location.reload();
            }
        };

        function rollDice() {
            const d1 = Math.floor(Math.random() * 6) + 1;
            const d2 = Math.floor(Math.random() * 6) + 1;
            const total = d1 + d2;
            const detail = `(${d1} + ${d2})`;
            document.getElementById('dice-result').innerText = total;
            document.getElementById('dice-detail').innerText = detail;
            sendData({ type: 'ROLL_DICE', result: total, detail: detail });
        }

        function initGame() {
            const saved = localStorage.getItem(SAVE_KEY);
            if (saved) {
                restoreBoardState(saved, true);
            } else {
                createDefaultUnits();
                createDefaultTerrain();
                saveGame(true);
            }
        }

        function createDefaultUnits() {
            const sides = ['red', 'blue'];
            const deployYPositions = [inchesToPx(DEPLOY_INCHES), tableHeightPx - inchesToPx(DEPLOY_INCHES)];

            const races = ["Elf", "Human", "Orc", "Dwarf", "Undead"];
            const types = ["Archers", "Swords", "Spears", "Cavalry", "Skirmishers", "Mounted Bowmen"];

            sides.forEach((color, sideIndex) => {
                const yPos = deployYPositions[sideIndex];
                const spacing = tableWidthPx / 7;
                const initialAngle = (sideIndex === 0) ? 180 : 0;

                // Generate all possible combinations
                let deck = [];
                races.forEach(race => {
                    types.forEach(type => {
                        deck.push(`${race} ${type}`);
                    });
                });

                // Shuffle deck (Fisher-Yates)
                for (let i = deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [deck[i], deck[j]] = [deck[j], deck[i]];
                }

                // Slice the first 6 unique units
                const unitNames = deck.slice(0, 6);

                unitNames.forEach((name, i) => {
                    const x = (spacing * (i + 1)) - (unitWidthPx / 2);
                    const y = yPos - (unitHeightPx / 2);
                    createUnitDOM(name, color, x, y, initialAngle, 0);
                });
            });
        }

        function createDefaultTerrain() {
            const terrainTypes = ['forest', 'forest', 'hills', 'hills', 'rough', 'rough'];
            terrainTypes.forEach((type) => {
                const w = inchesToPx(TERRAIN_DEFAULT_W);
                const h = inchesToPx(TERRAIN_DEFAULT_H);
                const x = Math.random() * (tableWidthPx - w - 100) + 50;
                const y = Math.random() * (inchesToPx(26) - inchesToPx(10)) + inchesToPx(10);
                const angle = Math.floor(Math.random() * 360);
                createTerrainDOM(type, x, y, w, h, angle);
            });
        }

        window.spawnTerrain = function (type) {
            pushUndo();
            const w = inchesToPx(TERRAIN_DEFAULT_W);
            const h = inchesToPx(TERRAIN_DEFAULT_H);
            const div = createTerrainDOM(type, -9999, -9999, w, h, 0);
            activePiece = div;
            ghostPiece = null;
            anchorX = -1;
            div.dataset.offsetX = w / 2;
            div.dataset.offsetY = h / 2;
            saveGame();
        };

        function attachListeners(element) {
            element.addEventListener('mousedown', onPieceDragStart);
            element.addEventListener('wheel', onWheel);
        }

        // --- INPUT HANDLING ---
        window.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
            if (e.key === 'z') { undo(); return; }
            if (e.key.toLowerCase() === 'r' && hoveredUnit) showRangeRing(hoveredUnit);

            const isPlus = (e.key === '+' || e.key === '=' || e.code === 'NumpadAdd');
            const isMinus = (e.key === '-' || e.key === '_' || e.code === 'NumpadSubtract');
            if (!isPlus && !isMinus) return;

            pushUndo();

            if (hoveredUnit) {
                let wounds = parseInt(hoveredUnit.dataset.wounds);
                const marker = hoveredUnit.querySelector('.wound-marker');
                if (isPlus) wounds++;
                if (isMinus && wounds > 0) wounds--;
                hoveredUnit.dataset.wounds = wounds;
                marker.innerText = wounds;
                marker.style.display = (wounds > 0) ? 'flex' : 'none';
            }
            else if (hoveredTerrain) {
                let w = parseFloat(hoveredTerrain.style.width);
                let h = parseFloat(hoveredTerrain.style.height);
                const factor = isPlus ? 1.1 : 0.9;
                hoveredTerrain.style.width = `${w * factor}px`;
                hoveredTerrain.style.height = `${h * factor}px`;
            }
            saveGame();
        });

        window.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'r') removeRangeRing();
        });

        // --- TOUCH / CAMERA LOGIC ---
        function initTouchControls() {
            let lastDist = 0;
            let lastCenter = null;
            let isPanning = false;
            let lastPan = { x: 0, y: 0 };
            let touchStartTime = 0;
            let touchStartPos = { x: 0, y: 0 };
            const TAP_DELAY = 300;
            let lastTapTime = 0;

            VIEWPORT.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const target = e.target;
                    // Check if we touched a UI element or a Piece
                    const isPiece = target.classList.contains('piece') || target.classList.contains('wound-btn') || target.classList.contains('rotate-handle');

                    if (!isPiece) {
                        // Background touch -> Pan or Tap preparation
                        isPanning = true;
                        touchStartTime = Date.now();
                        touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                        lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    }
                } else if (e.touches.length === 2) {
                    // Pinch start
                    isPanning = false;
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    lastDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    lastCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };
                }
            }, { passive: false });

            VIEWPORT.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent native scroll
                if (e.touches.length === 1 && isPanning) {
                    const cx = e.touches[0].clientX;
                    const cy = e.touches[0].clientY;
                    const dx = cx - lastPan.x;
                    const dy = cy - lastPan.y;
                    camera.x += dx;
                    camera.y += dy;
                    lastPan = { x: cx, y: cy };
                    updateCameraTransform();
                } else if (e.touches.length === 2) {
                    const t1 = e.touches[0];
                    const t2 = e.touches[1];
                    const newDist = Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
                    const newCenter = { x: (t1.clientX + t2.clientX) / 2, y: (t1.clientY + t2.clientY) / 2 };

                    if (lastDist > 0) {
                        const scale = newDist / lastDist;
                        // Zoom towards center
                        // oldPos = (center - cam) / oldScale
                        // newPos = (center - newCam) / newScale
                        // We want world pos of center to remain same.

                        // Simple zoom:
                        const zoomFactor = scale;
                        const newScale = camera.scale * zoomFactor;
                        // Clamp scale
                        if (newScale > 0.2 && newScale < 5.0) {
                            // Translate to keep center stable
                            // v = (c - t) / s
                            // t_new = c - v * s_new
                            const vx = (newCenter.x - VIEWPORT.getBoundingClientRect().left - camera.x) / camera.scale;
                            const vy = (newCenter.y - VIEWPORT.getBoundingClientRect().top - camera.y) / camera.scale;

                            camera.scale = newScale;
                            camera.x = (newCenter.x - VIEWPORT.getBoundingClientRect().left) - vx * camera.scale;
                            camera.y = (newCenter.y - VIEWPORT.getBoundingClientRect().top) - vy * camera.scale;

                            updateCameraTransform();
                        }
                    }
                    lastDist = newDist;
                    lastCenter = newCenter;
                }
            }, { passive: false });

            VIEWPORT.addEventListener('touchend', (e) => {
                if (isPanning && e.touches.length === 0) {
                    isPanning = false;
                    const dur = Date.now() - touchStartTime;
                    const touchEndPos = (e.changedTouches.length > 0) ? e.changedTouches[0] : touchStartPos; // Fallback
                    const dist = Math.hypot(touchEndPos.clientX - touchStartPos.x, touchEndPos.clientY - touchStartPos.y);

                    // Tap Detection
                    if (dur < TAP_DELAY && dist < 10) {
                        const now = Date.now();
                        if (now - lastTapTime < 300) {
                            // Double Tap
                            rollDice();
                            lastTapTime = 0;
                        } else {
                            // Single Tap
                            lastTapTime = now;
                            setTimeout(() => {
                                if (lastTapTime === now) { // Ensure not double tap
                                    handleTap(e);
                                }
                            }, 350);
                        }
                    }
                }
            });
        }

        // --- SELECTION / INTERACTION ---
        let selectedUnit = null;

        function handleTap(e) {
            // Check if we tapped a unit (Need raycast or similar since e.target might be viewport on empty space)
            // Actually, if we tapped the background (since isPanning was true), then we Deselect.
            // If we tapped a UNIT, the event wouldn't have triggered the background logic above because of the isPiece check?
            // Wait, if I prevent default on touchstart for pieces, they might not click.
            // Let's rely on standard events for pieces and use this callback for Background Taps.

            // If we are here, we tapped the "Background" or something that didn't stop propagation.
            if (selectedUnit) {
                deselectUnit();
            } else if (isMeasuring) {
                // Clean up measuring?
            }
        }

        function selectUnit(unitEl) {
            if (selectedUnit) deselectUnit();
            selectedUnit = unitEl;

            const ring = document.getElementById('selection-ui');
            ring.style.display = 'block';

            // Reparent ring or just move it? Moving is better for performance usually, but reparenting ensures it moves with unit.
            // But unit is `absolute`. Let's just append.
            unitEl.appendChild(ring);

            // Show values
            // ...
        }

        function deselectUnit() {
            const ring = document.getElementById('selection-ui');
            ring.style.display = 'none';
            document.getElementById('game-table').appendChild(ring); // Return to pool
            selectedUnit = null;
            document.getElementById('stats-popover').style.display = 'none';
        }

        function showRangeRing(unit) {
            if (unit.querySelector('.range-ring')) return;
            const ring = document.createElement('div');
            ring.classList.add('range-ring');
            const diameterPx = inchesToPx(THREAT_RANGE_INCHES * 2);
            ring.style.width = `${diameterPx}px`;
            ring.style.height = `${diameterPx}px`;
            ring.style.left = '50%';
            ring.style.top = '50%';
            unit.appendChild(ring);
        }
        function removeRangeRing() {
            document.querySelectorAll('.range-ring').forEach(r => r.remove());
        }

        // Helper to get pointer position in table coordinates
        function getPointerPos(e) {
            const tableRect = document.getElementById('game-table').getBoundingClientRect();
            let clientX, clientY;

            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if (e.changedTouches && e.changedTouches.length > 0) { // For touchend
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Convert client coordinates to table coordinates
            // tableRect.left is already the screen position of the table's (0,0) point (due to transform-origin: 0 0)
            const tableX = (clientX - tableRect.left) / camera.scale;
            const tableY = (clientY - tableRect.top) / camera.scale;
            return { x: tableX, y: tableY };
        }

        // --- INTERACTION STATE ---
        let interactionMode = 'none'; // 'move', 'rotate'
        let initialDragPos = { x: 0, y: 0 }; // For straight line constraint
        let initialUnitPos = { x: 0, y: 0 };
        let longPressTimer = null;

        // Initialize UI Listeners
        function initUIListeners() {
            const handle = document.getElementById('rotate-handle');
            const btnPlus = document.getElementById('btn-plus');
            const btnMinus = document.getElementById('btn-minus');

            // Rotate Handle
            const startRotate = (e) => {
                e.preventDefault(); e.stopPropagation();
                if (!selectedUnit) return;
                activePiece = selectedUnit;
                interactionMode = 'rotate';
                pushUndo();
            };
            handle.addEventListener('mousedown', startRotate);
            handle.addEventListener('touchstart', startRotate, { passive: false });

            // Window/Viewport handlers for rotate move are shared with onMouseMove

            // Wound Buttons
            const changeWounds = (delta) => {
                if (!selectedUnit) return;
                let wounds = parseInt(selectedUnit.dataset.wounds) || 0;
                const newVal = Math.max(0, wounds + delta);
                selectedUnit.dataset.wounds = newVal;

                // Update Marker
                let marker = selectedUnit.querySelector('.wound-marker');
                if (!marker) { // Should exist but safety check
                    marker = document.createElement('div');
                    marker.classList.add('wound-marker');
                    selectedUnit.appendChild(marker);
                }
                marker.innerText = newVal;
                marker.style.display = (newVal > 0) ? 'flex' : 'none';

                saveGame();
            };

            btnPlus.addEventListener('touchstart', (e) => { e.stopPropagation(); changeWounds(1); });
            btnPlus.addEventListener('mousedown', (e) => { e.stopPropagation(); changeWounds(1); });

            btnMinus.addEventListener('touchstart', (e) => { e.stopPropagation(); changeWounds(-1); });
            btnMinus.addEventListener('mousedown', (e) => { e.stopPropagation(); changeWounds(-1); });
        }

        // --- DRAG LOGIC ---
        function onPieceDown(e) {
            if (e.type === 'mousedown' && e.button !== 0) return;
            // e.preventDefault(); // allow focus?
            e.stopPropagation();

            // If we hit a UI element (that didn't stop prop), ignore unit drag
            if (e.target.closest('.wound-btn') || e.target.closest('.rotate-handle')) return;

            const targetUnit = e.currentTarget;

            // Long Press Logic
            longPressTimer = setTimeout(() => {
                // Show Stats
                updateStatsPanel(targetUnit.dataset.name);
                // Show popup at position
                const pop = document.getElementById('stats-popover');
                pop.innerHTML = document.getElementById('stats-panel').innerHTML;
                pop.style.display = 'block';

                const rect = targetUnit.getBoundingClientRect(); // Screen coords
                pop.style.left = rect.left + 'px';
                pop.style.top = (rect.bottom + 10) + 'px';

                // Cancel drag if long press triggered?
                activePiece = null;
                interactionMode = 'none';
            }, 600);

            if (activePiece) return; // Already doing something?

            pushUndo();
            activePiece = targetUnit;
            interactionMode = 'move';
            selectUnit(activePiece);

            // Init Drag Vars
            const pos = getPointerPos(e);
            initialDragPos = pos;
            initialUnitPos = {
                x: parseFloat(activePiece.style.left),
                y: parseFloat(activePiece.style.top)
            };

            activePiece.dataset.dragOffsetX = pos.x - initialUnitPos.x;
            activePiece.dataset.dragOffsetY = pos.y - initialUnitPos.y;

            // Ghost
            ghostPiece = activePiece.cloneNode(true);
            ghostPiece.classList.add('ghost');
            ghostPiece.removeAttribute('id');
            const ghostRing = ghostPiece.querySelector('.selection-ring');
            if (ghostRing) ghostRing.remove();
            ghostPiece.style.transform = activePiece.style.transform;
            document.getElementById('game-table').appendChild(ghostPiece);

            // Measure Line Anchor
            anchorX = initialUnitPos.x + (parseFloat(activePiece.style.width) / 2);
            anchorY = initialUnitPos.y + (parseFloat(activePiece.style.height) / 2);
            showLine(anchorX, anchorY, anchorX, anchorY);
        }

        // Bind to both mousedown and touchstart
        function attachListeners(element) {
            element.addEventListener('mousedown', onPieceDown);
            element.addEventListener('touchstart', onPieceDown, { passive: false });
            element.addEventListener('wheel', onWheel);
        }

        // Table measuring
        const gameTable = document.getElementById('game-table');
        // We need to bind to specific event that bubbles from background.
        // Actually `table` variable was defined earlier by ID.

        // Re-bind table mousedown for measuring (background only)
        gameTable.addEventListener('mousedown', (e) => {
            if (e.button !== 0) return;
            if (e.target !== gameTable && e.target !== document.getElementById('ui-layer')) return;
            isMeasuring = true;
            const pos = getPointerPos(e);
            anchorX = pos.x;
            anchorY = pos.y;
            showLine(anchorX, anchorY, anchorX, anchorY);
        });

        // We also need touchstart on viewport to handle "background tap" vs "background measure"?
        // Background measure might clash with Pan. 
        // In mobile strategy games, usually: One finger pan. Tape measure is a tool mode or two-finger?
        // "Click Empty: Measure" -> On mobile, maybe long press or specific tool? 
        // The user didn't specify. Left it as tap background deselects. 
        // Let's keep measuring for Desktop Mouse. For Mobile, standard behavior is Pan.

        function showLine(x1, y1, x2, y2) {
            const textEl = document.getElementById('measure-text');
            lineElement.style.opacity = 1;
            textEl.style.opacity = 1;
            lineElement.setAttribute('x1', x1);
            lineElement.setAttribute('y1', y1);
            lineElement.setAttribute('x2', x2);
            lineElement.setAttribute('y2', y2);
            textEl.innerHTML = '0"';
        }

        function onMouseMove(e) {
            // Cancel Long Press on move
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }

            if (!activePiece && !isMeasuring) return;
            const pos = getPointerPos(e);

            if (activePiece) {
                if (interactionMode === 'move') {
                    // Straight Line Constraint Logic
                    // " Drag the unit to move it in a straight line in that direction. "
                    // Interpretation: The movement is vector-based from origin.
                    // We implement standard drag, but we could lock axis if shift held? 
                    // User request: "Drag the unit to move it in a straight line in that direction"
                    // This sounds like standard drag behavior (you drag in a line). 
                    // If they meant "Snap to grid" or "Snap to Angle", they'd say so.
                    // I will implement standard drag for now.

                    // Wait, maybe they mean "Unit faces movement direction"? 
                    // "Drag this circle to rotate the unit. Drag the unit to move it in a straight line in that direction."
                    // It implies decoupling rotation and movement.
                    // I'll stick to translation only.

                    const offX = parseFloat(activePiece.dataset.dragOffsetX);
                    const offY = parseFloat(activePiece.dataset.dragOffsetY);
                    const newLeft = pos.x - offX;
                    const newTop = pos.y - offY;

                    activePiece.style.left = `${newLeft}px`;
                    activePiece.style.top = `${newTop}px`;

                    const centerX = newLeft + (parseFloat(activePiece.style.width) / 2);
                    const centerY = newTop + (parseFloat(activePiece.style.height) / 2);

                    // Update measure line to center
                    if (anchorX > -1) {
                        lineElement.setAttribute('x2', centerX);
                        lineElement.setAttribute('y2', centerY);
                        // ... rest of measure update logic is same
                        const dx = centerX - anchorX;
                        const dy = centerY - anchorY;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const textEl = document.getElementById('measure-text');
                        textEl.innerHTML = `${pxToInches(dist)}"`;
                        textEl.setAttribute('x', anchorX + dx / 2 + 10);
                        textEl.setAttribute('y', anchorY + dy / 2 - 10);
                    }

                } else if (interactionMode === 'rotate') {
                    // Calculate angle from unit center to pointer
                    const rect = activePiece.getBoundingClientRect(); // Screen
                    // We can use screen coords for angle calc since angle is preserved?
                    // Or use table coords.

                    const unitX = parseFloat(activePiece.style.left) + parseFloat(activePiece.style.width) / 2;
                    const unitY = parseFloat(activePiece.style.top) + parseFloat(activePiece.style.height) / 2;

                    const dx = pos.x - unitX;
                    const dy = pos.y - unitY;

                    // +90 because 0 deg is usually "Up" or "Right"? 
                    // Check HTML: 180 is facing down. 0 is facing up?
                    // If 0 is Up (Negative Y).
                    // atan2(y, x). 
                    // 0, -1 -> -90 deg.
                    // 1, 0 -> 0 deg? 
                    // Let's just try standard atan2 and offset.
                    // atan2 returns radians from X axis.
                    // We want degrees.
                    let angle = Math.atan2(dy, dx) * 180 / Math.PI;
                    activePiece.dataset.angle = angle + 90; // +90 to align with standard web rotation?
                    activePiece.style.transform = `rotate(${activePiece.dataset.angle}deg)`;
                }
            } else if (isMeasuring) {
                // Measuring Logic
                const targetX = pos.x;
                const targetY = pos.y;
                lineElement.setAttribute('x2', targetX);
                lineElement.setAttribute('y2', targetY);
                const dx = targetX - anchorX;
                const dy = targetY - anchorY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const textEl = document.getElementById('measure-text');
                textEl.innerHTML = `${pxToInches(dist)}"`;
                textEl.setAttribute('x', anchorX + dx / 2 + 10);
                textEl.setAttribute('y', anchorY + dy / 2 - 10);
            }
        }

        function onMouseUp(e) {
            if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

            if (activePiece) saveGame();
            activePiece = null;
            interactionMode = 'none';
            isMeasuring = false;

            if (ghostPiece) { ghostPiece.remove(); ghostPiece = null; }
            lineElement.style.opacity = 0;
            document.getElementById('measure-text').style.opacity = 0;
        }

        function onWheel(e) {
            e.preventDefault(); e.stopPropagation();
            pushUndo();
            const piece = e.currentTarget;
            let currentAngle = parseFloat(piece.dataset.angle) || 0;
            // If Shift pressed, rotate 1 degree, else 15
            const step = e.shiftKey ? 1 : 15;
            if (e.deltaY > 0) currentAngle += step;
            else currentAngle -= step;
            piece.dataset.angle = currentAngle;
            piece.style.transform = `rotate(${currentAngle}deg)`;
            saveGame();
        }

        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        window.addEventListener('touchmove', onMouseMove, { passive: false }); // Add touchmove for dragging pieces
        window.addEventListener('touchend', onMouseUp); // Add touchend for releasing pieces

        initGame();
        initTouchControls();
        initUIListeners();
    </script>
</body>

</html>